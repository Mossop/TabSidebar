<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2006
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings [
<!ENTITY % bidiDTD SYSTEM "chrome://global/locale/global.dtd">
<!ENTITY % tabbrowserDTD SYSTEM "chrome://global/locale/tabbrowser.dtd" >
<!ENTITY % tabSidebarDTD SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd" >
%bidiDTD;
%tabbrowserDTD;
%tabSidebarDTD;
]>

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews" extends="chrome://tabsidebar/content/widgets/tabpreviews.xml#tabpreviews">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/widgets/tabpreviews.css"/>
    </resources>
    
    <content class="tbs-tabpreviews-vertical" hide="" align="stretch" orient="vertical" style="visibility: hidden">
      <xul:popupset>
      
        <xul:tooltip id="tabpreview_tooltip" orient="vertical" align="left">
          <xul:label class="tbs-tooltip-title" value="Title"/>
          <xul:label class="tbs-tooltip-uri" value="URI"/>
          <xul:image/>
        </xul:tooltip>
        
      </xul:popupset>
        
      <xul:hbox class="tbs-drop-indicator-bar">
        <xul:vbox chromedir="&locale.dir;" class="tbs-drop-indicator"/>
      </xul:hbox>          

      <xul:box class="tbs-focusdetector" style="-moz-user-focus: normal"/>
      
      <xul:scrollbox class="tbs-scrollbox" allowevents="true" anonid="scrollbox"
                     ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode); event.stopPropagation();"
                     ondragover="nsDragAndDrop.dragOver(event, this.parentNode); event.stopPropagation();"
                     ondragdrop="nsDragAndDrop.drop(event, this.parentNode); event.stopPropagation();"
                     ondragexit="nsDragAndDrop.dragExit(event, this.parentNode); event.stopPropagation();"
                     align="stretch" flex="1" orient="horizontal">
        
        <children/>

      </xul:scrollbox>
    </content>
    
    <implementation>

      <field name="previewContainer">this</field>
      <field name="focusDetector">this.ownerDocument.getAnonymousNodes(this)[2]</field>
      <field name="scrollBox">this.ownerDocument.getAnonymousNodes(this)[3]</field>
      <field name="scrollBoxObject">this.scrollBox.boxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject)</field>
      <field name="dragDropBar">this.ownerDocument.getAnonymousNodes(this)[1]</field>
      <field name="dragDropIndicator">this.dragDropBar.firstChild;</field>

      <method name="_resizePreview">
        <parameter name="preview"/>
        <body>
        <![CDATA[
          if (this.displayWidth<0)
          {
            this._logWarning("Attempt to resize preview before size has been calculated");
            return;
          }

          var canvas = preview.canvas;

          preview._topbox.style.width=this.displayWidth+"px";
          preview._bottombox.style.width=this.displayWidth+"px";
          canvas.style.width=this.displayWidth+"px";
          canvas.style.minWidth=this.displayWidth+"px";
          canvas.style.maxWidth=this.displayWidth+"px";
          canvas.style.height=this.displayHeight+"px";
          canvas.style.minHeight=this.displayHeight+"px";
          canvas.style.maxHeight=this.displayHeight+"px";
          
          try
          {
            canvas.getContext("2d");
          }
          catch (e)
          {
          }
        ]]>
        </body>
      </method>
      
      <method name="ensureElementsAreVisible">
        <parameter name="first"/>
        <parameter name="last"/>
        <body>
        <![CDATA[
          var x = {};
          this.scrollBoxObject.getPosition(x, {});
          var scrollLeft = x.value;
          var scrollWidth = this.scrollBox.boxObject.width;

          var elleft = first.boxObject.x;
          var style = window.getComputedStyle(first,null);
          elleft-=parseInt(style.marginLeft)+parseInt(style.borderLeftWidth);
          
          var elright = last.boxObject.x+last.boxObject.width;
          style = window.getComputedStyle(last,null);
          elright+=parseInt(style.marginRight)+parseInt(style.borderRightWidth);

          if (scrollLeft>elleft)
          {
            this.scrollBoxObject.scrollBy(elleft-scrollLeft, 0);
          }
          else if ((scrollLeft+scrollWidth)<elright)
          {
            var shift = elright-(scrollLeft+scrollWidth);
            if ((scrollLeft+shift)>elleft)
            {
              shift=elleft-scrollLeft;
            }
            this.scrollBoxObject.scrollBy(shift,0);
          }
        ]]>
        </body>
      </method>
      
      <method name="browserResized">
        <parameter name="preview"/>
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
        <![CDATA[
          if (this._selected == preview)
          {
            var newWidth=0;
            var newHeight=0;

            var box = this.ownerDocument.getAnonymousNodes(this.scrollBox)[0];
            newHeight = this.scrollBoxObject.height-(preview.canvas.parentNode.boxObject.y-box.boxObject.y);
            newHeight-=28; // TODO MAGIC NUMBER

            if (newHeight<0)
            {
              this._logError("Invalid canvas height ("+newHeight+")");
              this._resizeTimer.initWithCallback(this, 
                                                 5,
                                                 Components.interfaces.nsITimer.TYPE_ONE_SHOT);
              return;
            }
            else if (newHeight==0)
            {
              this._logWarning("Zero canvas height");
            }

            newWidth = parseInt((width/height)*newHeight);
  
            if (this._displayWidth!=newWidth || this._displayHeight!=newHeight)
            {
              this._contentWidth=Math.max(newWidth,300);
              this._contentHeight=(newHeight/newWidth)*this._contentWidth;
              this._displayWidth=newWidth;
              this._displayHeight=newHeight;
              this._resize();
              this.style.visibility=null;
            }
          }
        ]]>
        </body>
      </method>
      
      <method name="_drawDropIndicator">
        <parameter name="drop"/>
        <body>
          if (drop!=this._lastDrop)
          {
            this.ensureElementsAreVisible(drop,drop);
            var x = {};
            this.scrollBoxObject.getPosition(x, {});
            var dropel = drop;
            if (drop.localName == "tabpreview")
            {
              dropel = drop.canvas.parentNode;
            }
            var pos = dropel.boxObject.x+(dropel.boxObject.width/2)-this.boxObject.x;
            pos = pos - x.value - 5;
            this.dragDropIndicator.style.marginLeft = pos + "px";
            if (!this._lastDrop)
            {
              this.dragDropBar.setAttribute("dragging","true");
            }
            this._lastDrop=drop;
          }
        </body>
      </method>
      
      <method name="getDropElement">
        <parameter name="aEvent"/>
        <parameter name="external"/>
        <body>
        <![CDATA[
          var x = {};
          this.scrollBoxObject.getPosition(x, {});
          var xpos = aEvent.clientX+x.value;
          var diff = 0;
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
          {
            var bo = previews[i].boxObject;
            if (external)
            {
              if (bo.x>xpos)
              {
                return previews[i].previousSibling;
              }
              else if ((bo.x+bo.width)>=xpos)
              {
                return previews[i];
              }
            }
            else
            {
              if ((bo.x+(bo.width/2))>xpos)
              {
                return previews[i].previousSibling;
              }
            }
          }
          return previews[previews.length-1].nextSibling;
        ]]>
        </body>
      </method>
      
      <method name="checkDragScroll">
        <parameter name="aEvent"/>
        <body>
        <![CDATA[
          var x = {};
          this.scrollBoxObject.getPosition(x, {});

          if (x.value>0 && aEvent.clientX<10)
          {
            this.scrollBoxObject.scrollBy(-20,0);
            this._hideDropIndicator();
            return true;
          }
          
          var right = this.ownerDocument.getAnonymousNodes(this.scrollBox)[0].boxObject.width-this.scrollBox.boxObject.width;
          
          if ((this.scrollBox.boxObject.width-aEvent.clientX)<10 && x.value<right)
          {
            this.scrollBoxObject.scrollBy(20,0);
            this._hideDropIndicator();
            return true;
          }
          
          return false;
        ]]>
        </body>
      </method>
      
    </implementation>
    
    <handlers>
      <handler event="keypress">
      <![CDATA[
        if (event.target.parentNode==this)
        {
          var preview = event.target;
          if (event.altKey||event.shiftKey||event.metaKey)
          {
            return;
          }
          else if (event.ctrlKey)
          {
            if (event.keyCode==event.DOM_VK_LEFT)
            {
              var newpreview = preview.previousSibling.previousSibling;
              if (newpreview)
              {
                this.movePreview(preview,newpreview);
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_RIGHT)
            {
              var newpreview = preview.nextSibling.nextSibling;
              if (newpreview)
              {
                this.movePreview(preview,newpreview.nextSibling.nextSibling);
              }
              event.preventDefault();
            }
          }
          else
          {
            if (event.keyCode==event.DOM_VK_LEFT)
            {
              var newpreview = preview.previousSibling.previousSibling;
              if (newpreview)
              {
                preview.tab.focus();
                this.tabbrowser.selectedTab=newpreview.tab;
                newpreview.focus();
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_RIGHT)
            {
              var newpreview = preview.nextSibling.nextSibling;
              if (newpreview)
              {
                preview.tab.focus();
                this.tabbrowser.selectedTab=newpreview.tab;
                newpreview.focus();
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_CONTEXT_MENU)
            {
              var preview = null;

              if (this._selected)
              {
                preview=this._selected;
              }
              else
              {
                preview=this.previews[0];
              }

              var x = preview.boxObject.screenX-this.window.document.documentElement.boxObject.screenX;
              var y = preview.boxObject.screenY-this.window.document.documentElement.boxObject.screenY;
    
              x+=2;
              y+=2;
              
              this.displayContextMenu(preview,x,y);
            }
          }
        }
      ]]>
      </handler>
    </handlers>
  </binding>
</bindings>
