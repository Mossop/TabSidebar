<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2006
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

#define MINBROWSERSIZE 20

<bindings id="TabSidebarBindings" xmlns="http://www.mozilla.org/xbl">

  <binding id="tabpreviews" name="tabpreviews">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/widgets/tabpreviews.css"/>
    </resources>
    
    <implementation implements="nsITimerCallback,nsIObserver">
    
      <field name="_validateTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      <field name="_validatePos">0</field>
      <field name="_validateMax">0</field>
      <field name="_browserHeight">0</field>
      <field name="_browserWidth">0</field>
      <field name="_newTabPosition">null</field>
      <field name="_seenSessionRestore">false</field>
      
      <constructor>
      <![CDATA[
        var docshell = window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                             .getInterface(Components.interfaces.nsIWebNavigation)
                             .QueryInterface(Components.interfaces.nsIDocShellTreeItem);
        docshell = docshell.rootTreeItem;
        this.window = docshell.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                              .getInterface(Components.interfaces.nsIDOMWindow);
        this.tabbrowser = this.window.document.getElementById("content");
        
        this._initTree();
        this._migrateOldSettings();
        this._initSettings();

#ifdef ${extension.debug}
        this._logMessage("Tab Sidebar Startup");
        
#endif
        this._initEvents();
        
        this._loadMetrics();
        this.init();
        if (this.window.__SSi)
        {
          this._restoreSession();
          this._seenSessionRestore = true;
        }
          
        if (this.showPreviews)
          this._updateSize();
        else
          this.style.visibility=null;
      ]]>
      </constructor>
      
      <method name="init">
        <body>
        <![CDATA[
#ifdef ${extension.debug}
          this._logMessage("Tab Sidebar Load");
          
#endif
          var selectedpos = -1;
          var browsers = this.tabbrowser.browsers;
          for (var i=0; i<browsers.length; i++)
          {
            if (this.tabbrowser.selectedBrowser==browsers[i])
            {
              selectedpos=i;
              break;
            }
          }
          var preview = this.addPreview(browsers[selectedpos]);
          if ((preview._browserWidth > 0) && (preview._browserHeight > 0))
            this.browserResized(preview, preview._browserWidth, preview._browserHeight);
          for (var i=selectedpos-1; i>=0; i--)
            this.addPreview(browsers[i]);
          for (var i=selectedpos+1; i<browsers.length; i++)
            this.addPreview(browsers[i]);
        ]]>
        </body>
      </method>
      
      <method name="_initTree">
        <body>
          var drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
          drop.className="dropindicator groove";
          if (this.getAttribute("orient")=="vertical")
            drop.setAttribute("orient","vertical");
          else
            drop.setAttribute("orient","horizontal");
          this.previewContainer.appendChild(drop);
        </body>
      </method>

      <method name="_migrateOldSettings">
        <body>
        <![CDATA[
          var oprefs = Components.classes["@mozilla.org/preferences-service;1"]
                                 .getService(Components.interfaces.nsIPrefService)
                                 .getBranch("tabsidebar.").QueryInterface(Components.interfaces.nsIPrefBranch);
          var list = oprefs.getChildList("",{});
          for (var i=0; i<list.length; i++)
          {
            if (oprefs.prefHasUserValue(list[i]))
            {
              var type = oprefs.getPrefType(list[i]);
              switch (type)
              {
                case Components.interfaces.nsIPrefBranch.PREF_STRING:
                  this.preferences.setStringPref(list[i],oprefs.getStringPref(list[i]));
                  break;
                case Components.interfaces.nsIPrefBranch.PREF_INT:
                  this.preferences.setIntPref(list[i],oprefs.getIntPref(list[i]));
                  break;
                case Components.interfaces.nsIPrefBranch.PREF_BOOL:
                  this.preferences.setBoolPref(list[i],oprefs.getBoolPref(list[i]));
                  break;
              }
              oprefs.clearUserPref(list[i]);
            }
          }
        ]]>
        </body>
      </method>

      <method name="_initSettings">
        <body>
#ifdef ${extension.debug}
          try
          {
            this._enableLogging = this.preferences.getBoolPref("enablelogging");
          }
          catch (e)
          {
          }

#endif
          this._showNavigation = this.preferences.getBoolPref("content.navigation");
          this._showPreviews = this.preferences.getBoolPref("content.previews");
          this._updatePreviews = this.preferences.getBoolPref("updatepreviews");
          this._scrollSelects = this.preferences.getBoolPref("scrollselects");

          this._drawScrolled = this.preferences.getBoolPref("drawscrolled");
          this._validateRate = this.preferences.getIntPref("validaterate");
          this._loadRefresh = this.preferences.getBoolPref("loadrefresh");
          this._loadRefreshRate = this.preferences.getIntPref("loadrefreshrate");
          this._loadErrorDelay = this.preferences.getIntPref("loaderrordelay");
          this._unselectedLoadErrorDelay = this.preferences.getIntPref("unselectedloaderrordelay");
          this._loadDelay = this.preferences.getIntPref("loaddelay");
          this._unselectedLoadDelay = this.preferences.getIntPref("unselectedloaddelay");
          this._textDelay = this.preferences.getIntPref("textdelay");
          this._unselectedTextDelay = this.preferences.getIntPref("unselectedtextdelay");
          this._changeDelay = this.preferences.getIntPref("changedelay");
          this._unselectedChangeDelay = this.preferences.getIntPref("unselectedchangedelay");
          this._scrollDelay = this.preferences.getIntPref("scrolldelay");
          this._unselectedScrollDelay = this.preferences.getIntPref("unselectedscrolldelay");
          
          this.updateContent();        
        </body>
      </method>
      
      <method name="_initEvents">
        <body>
          this.preferences.addObserver("", this, false);
          
          this.tabbrowser.addProgressListener(this._progressListener);

          this.tabbrowser.tabContainer.addEventListener("TabOpen", this._eventListener, false);
          this.tabbrowser.tabContainer.addEventListener("TabClose", this._eventListener, false);
          this.tabbrowser.tabContainer.addEventListener("TabMove", this._eventListener, false);
          this.tabbrowser.tabContainer.addEventListener("TabSelect", this._eventListener, false);
          this.tabbrowser.tabContainer.addEventListener("SSTabRestoring", this._eventListener, false);
          this.tabbrowser.tabContainer.addEventListener("SSTabRestored", this._eventListener, false);
        </body>
      </method>
      
      <method name="_loadMetrics">
        <body>
          if (this.preferences.prefHasUserValue("metrics.browserwidth"))
            this._browserWidth = this.preferences.getIntPref("metrics.browserwidth");
          if (this.preferences.prefHasUserValue("metrics.browserheight"))
            this._browserHeight = this.preferences.getIntPref("metrics.browserheight");
          if (this.preferences.prefHasUserValue("metrics.displaywidth"))
            this._displayWidth = this.preferences.getIntPref("metrics.displaywidth");
          if (this.preferences.prefHasUserValue("metrics.displayheight"))
            this._displayHeight = this.preferences.getIntPref("metrics.displayheight");
        </body>
      </method>
      
      <method name="_restoreSession">
        <body>
#ifdef ${extension.debug}
          this._logMessage("Restoring state");
#endif
          var ss = Components.classes["@mozilla.org/browser/sessionstore;1"]
                             .getService(Components.interfaces.nsISessionStore);
          var pos = ss.getWindowValue(this.window, "tabsidebar.scrollpos");
          if (pos)
            this.scrollTo(pos);
        </body>
      </method>
      
      <destructor>
#ifdef ${extension.debug}
        dump("Tabpreviews destructor\n");
#endif
        this._destroy();
      </destructor>
      
      <field name="_destroyed" value="false"/>
      <method name="_destroy">
        <body>
          if (!this._destroyed)
          {
            try
            {
              this._destroyed=true;
  
              this.tabbrowser.removeProgressListener(this._progressListener);
  
              while (this.firstChild)
              {
                if (this.firstChild.localName == "tabpreview")
                  this.firstChild._destroy();
                this.removeChild(this.firstChild);
              }
      
		          this.tabbrowser.tabContainer.removeEventListener("TabOpen", this._eventListener, false);
		          this.tabbrowser.tabContainer.removeEventListener("TabClose", this._eventListener, false);
		          this.tabbrowser.tabContainer.removeEventListener("TabMove", this._eventListener, false);
		          this.tabbrowser.tabContainer.removeEventListener("TabSelect", this._eventListener, false);
              this.tabbrowser.tabContainer.removeEventListener("SSTabRestoring", this._eventListener, false);
              this.tabbrowser.tabContainer.removeEventListener("SSTabRestored", this._eventListener, false);
      
              this.preferences.removeObserver("", this);
              
              this.preferences = null;
              this._eventListener.tabpreviews = null;
              this._eventListener = null;
              this._validateTimer.cancel();
              this._validateTimer = null;
              this._progressListener.tabpreviews = null;
              this._progressListener = null;
              this._selected = null;
              this._lastDrop = null;
              this.tabbrowser = null;
              this.window = null;
    
#ifdef ${extension.debug}
              //dump("Tabpreviews destroyed\n");
#endif
            }
            catch (e)
            {
#ifdef ${extension.debug}
              dump(e+"\n");
#endif
            }
          }
        </body>
      </method>
      
      <method name="_storeSession">
        <body>
          if (!this._seenSessionRestore)
            return;
            
          var ss = Components.classes["@mozilla.org/browser/sessionstore;1"]
                             .getService(Components.interfaces.nsISessionStore);
          ss.setWindowValue(this.window, "tabsidebar.scrollpos", this.getScrollPosition());
        </body>
      </method>
      
      <method name="_saveMetrics">
        <body>
          this.preferences.setIntPref("metrics.browserwidth", this._browserWidth);
          this.preferences.setIntPref("metrics.browserheight", this._browserHeight);
          this.preferences.setIntPref("metrics.displaywidth", this._displayWidth);
          this.preferences.setIntPref("metrics.displayheight", this._displayHeight);
        </body>
      </method>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener">({
        tabpreviews: this,
        
        handleEvent: function(event)
        {
#ifdef ${extension.debug}
        	this.tabpreviews._logMessage("Event - "+event.type);
#endif
          if (event.type=="TabOpen")
          {
            if (this.tabpreviews._newTabPosition)
            {
#ifdef ${extension.debug}
              this.tabpreviews._logMessage("New tab that needs moving to " + this.tabpreviews._newTabPosition.tab._tPos);
#endif
              this.tabpreviews.tabbrowser.moveTabTo(event.target, this.tabpreviews._newTabPosition.tab._tPos);
              this.tabpreviews._newTabPosition = null;
              return;
            }

            var browser = event.target.linkedBrowser;
            var preview = this.tabpreviews.addPreview(browser);
            if (this.tabpreviews.showPreviews)
              preview.redraw();
          }
          else if (event.type=="TabClose")
          {
            var browser = event.target.linkedBrowser;
            this.tabpreviews.removePreview(browser);
          }
          else if (event.type=="TabMove")
          {
            var browser = event.target.linkedBrowser;
            this.tabpreviews.removePreview(browser);
            var preview = this.tabpreviews.addPreview(browser);
            if (this.tabpreviews.showPreviews)
              preview.redraw();
          }
          else if (event.type=="TabSelect")
          {
            var newBrowser = this.tabpreviews.tabbrowser.getBrowserForTab(this.tabpreviews.tabbrowser.selectedTab);
            this.tabpreviews.selectPreview(newBrowser);
          }
          else if (event.type=="SSTabRestoring")
          {
            if (!this.tabpreviews._seenSessionRestore)
            {
              this.tabpreviews._restoreSession();
              this.tabpreviews._seenSessionRestore = true;
            }
            var preview = this.tabpreviews.getPreviewForBrowser(event.target.linkedBrowser);
            if (preview)
              preview.startRestoringSession();
          }
          else if (event.type=="SSTabRestored")
          {
            var preview = this.tabpreviews.getPreviewForBrowser(event.target.linkedBrowser);
            if (preview)
              preview.endRestoringSession();
          }
        }
      });</field>

      <field name="_progressListener">({
          tabpreviews: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
          },

          onLinkIconAvailable : function(browser)
          {
            var preview = this.tabpreviews.getPreviewForBrowser(browser);
            if (preview)
              preview.onLinkIconAvailable();
          },
          
          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>

      <!-- Internal fields and methods -->

      <field name="_selected"/>
      
      <method name="_resize">
        <body>
        <![CDATA[
          var previews = this.previews;
#ifdef ${extension.debug}
          if (previews.length>0)
            this._logMessage("Resizing to "+this.displayWidth+"x"+this.displayHeight);
#endif
          for (var i=0; i<previews.length; i++)
            this._resizePreview(previews[i]);
          this._checkScrollPosition();
          this._updateScrollButtons();
        ]]>
        </body>
      </method>
      
#ifdef ${extension.debug}
      <method name="_logMessage">
        <parameter name="message"/>
        <body>
          if (this._enableLogging)
          {
            Components.classes['@mozilla.org/consoleservice;1']
                      .getService(Components.interfaces.nsIConsoleService)
                      .logStringMessage("Tab Previews: "+message);
          }
        </body>
      </method>
      
      <method name="_logWarning">
        <parameter name="message"/>
        <body>
          if (this._enableLogging)
          {
            var msg = Components.classes["@mozilla.org/scripterror;1"].createInstance(Components.interfaces.nsIScriptError);
            
            msg.init("Tab Previews: "+message,
                     "chrome://tabsidebar/content/widgets/tabpreviews.xml",
                     "",
                     0,
                     0,
                     Components.interfaces.nsIScriptError.warningFlag,
                     "XUL JavaScript");
            
            var console = Components.classes["@mozilla.org/consoleservice;1"]
                                    .getService(Components.interfaces.nsIConsoleService);
            console.logMessage(msg);
          }
        </body>
      </method>
      
      <method name="_logError">
        <parameter name="message"/>
        <body>
          if (this._enableLogging)
          {
            var msg = Components.classes["@mozilla.org/scripterror;1"].createInstance(Components.interfaces.nsIScriptError);
            
            msg.init("Tab Previews: "+message,
                     "chrome://tabsidebar/content/widgets/tabpreviews.xml",
                     "",
                     0,
                     0,
                     Components.interfaces.nsIScriptError.errorFlag,
                     "XUL JavaScript");
            
            var console = Components.classes["@mozilla.org/consoleservice;1"]
                                    .getService(Components.interfaces.nsIConsoleService);
            console.logMessage(msg);
          }
        </body>
      </method>

#endif
      <!-- Helper properties -->

      <field name="preferences">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefService)
                  .getBranch("extensions.tabsidebar.").QueryInterface(Components.interfaces.nsIPrefBranchInternal);
      </field>
      <field name="tabbrowser"/>
      <field name="window"/>
      
      <property name="previews">
        <getter>
          return this.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

#ifdef ${extension.debug}
      <field name="_enableLogging">false</field>
      <property name="enableLogging" onget="return this._enableLogging;"/>
      
#endif
      <field name="_scrollSelects">false</field>
      <property name="scrollSelects" onget="return this._scrollSelects;"/>
      
      <field name="_showPreviews">false</field>
      <property name="showPreviews" onget="return this._showPreviews;"/>
      
      <field name="_updatePreviews">false</field>
      <property name="updatePreviews" onget="return (this._updatePreviews &amp;&amp; this._showPreviews);"/>
      
      <field name="_showNavigation">false</field>
      <property name="showNavigation" onget="return this._showNavigation;"/>
      
      <field name="_displayWidth">-1</field>
      <property name="displayWidth" onget="return this._displayWidth;"/>
      
      <field name="_displayHeight">-1</field>
      <property name="displayHeight" onget="return this._displayHeight;"/>
      
      <field name="_contentWidth">-1</field>
      <property name="contentWidth" onget="return this._contentWidth;"/>
      
      <field name="_contentHeight">-1</field>
      <property name="contentHeight" onget="return this._contentHeight;"/>
      
      <field name="_loadRefresh"/>
      <property name="loadRefresh" onget="return (this._loadRefresh &amp;&amp; this.updatePreviews);"/>
      
      <field name="_loadRefreshRate"/>
      <property name="loadRefreshRate">
        <getter>
          return Math.max(100,this._loadRefreshRate);
        </getter>
      </property>
      
      <field name="_loadErrorDelay"/>
      <property name="loadErrorDelay" onget="return this._loadErrorDelay;"/>
      
      <field name="_unselectedLoadErrorDelay"/>
      <property name="unselectedLoadErrorDelay" onget="return this._unselectedLoadErrorDelay;"/>
      
      <field name="_loadDelay"/>
      <property name="loadDelay" onget="return this._loadDelay;"/>
      
      <field name="_unselectedLoadDelay"/>
      <property name="unselectedLoadDelay" onget="return this._unselectedLoadDelay;"/>
      
      <field name="_changeDelay"/>
      <property name="changeDelay" onget="return this._changeDelay;"/>
      
      <field name="_unselectedChangeDelay"/>
      <property name="unselectedChangeDelay" onget="return this._unselectedChangeDelay;"/>
      
      <field name="_textDelay"/>
      <property name="textDelay" onget="return this._textDelay;"/>
      
      <field name="_unselectedTextDelay"/>
      <property name="unselectedTextDelay" onget="return this._unselectedTextDelay;"/>
      
      <field name="_scrollDelay"/>
      <property name="scrollDelay" onget="return this._scrollDelay;"/>
      
      <field name="_unselectedScrollDelay"/>
      <property name="unselectedScrollDelay" onget="return this._unselectedScrollDelay;"/>
      
      <field name="_drawScrolled"/>
      <property name="drawScrolled">
        <getter>
          return this._drawScrolled;
        </getter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var id=browser.parentNode.id;
          var preview = this.getElementsByAttribute("browser", id);
          if (preview.length>0)
            return preview[0];
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
          {
            var preview = previews[i];
            if (preview.browser==browser)
            {
              if (id)
                preview.setAttribute("browser", id);
              return preview;
            }
          }
          return null;
        ]]>
        </body>
      </method>
      
      <method name="getTabForPreview">
        <parameter name="preview"/>
        <body>
          var tabbrowser = this.tabbrowser;
          var panel = preview._browser.parentNode.id;
          return tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = this.getPreviewForBrowser(browser);
          var drop = null;
          if (preview)
          {
#ifdef ${extension.debug}
            this._logMessage("Found preview: "+preview);
#endif
            preview._destroy();
            var drop = preview.nextSibling;
          }
          else
          {
            preview = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","tabpreview");
            drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
            drop.className="dropindicator groove";
            if (this.getAttribute("orient")=="vertical")
              drop.setAttribute("orient","vertical");
            else
              drop.setAttribute("orient","horizontal");
          }
          var id=browser.parentNode.id;
          if (id)
            preview.setAttribute("browser", id);
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
          var next = null;
          if (tab && tab.nextSibling)
            next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
          this.previewContainer.insertBefore(preview,next);
          this.previewContainer.insertBefore(drop,next);

          preview.init();

          if (this.tabbrowser.selectedBrowser==browser)
          {
            this.selectPreview(browser);
          }
          else if (tab && tab.hasAttribute("selected"))
            preview.selected=(tab.getAttribute("selected")=="true");
          
          preview.browser=browser;
          this._updateScrollButtons();
          return preview;
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          if (preview)
          {
            if (this._selected==preview)
              this._selected=null;
              
            var drop = preview.nextSibling;
            preview._destroy();
            preview.parentNode.removeChild(preview);
            drop.parentNode.removeChild(drop);
            this._checkScrollPosition();
            this._updateScrollButtons();
          }
#ifdef ${extension.debug}
          else if (!this._newTabPosition)
          {
          	this._logWarning("Attempt to remove an unknown preview");
          }
#endif
        </body>
      </method>
      
      <method name="scrollToPreview">
        <parameter name="preview"/>
        <body>
          this.ensureElementsAreVisible(preview.previousSibling,preview.nextSibling);
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = this.getPreviewForBrowser(browser);
          if (this._selected)
            this._selected.selected=false;
          if (preview)
          {
            preview.selected=true;
            this.scrollToPreview(preview);
          }
          this._selected=preview;
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          if (!this.showPreviews)
            return;
            
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="updateContent">
        <body>
        <![CDATA[
          var hide = "";
          if (!this.showNavigation)
            hide+=" navigation";
          if (!this.showPreviews)
            hide+=" preview";
          
          if (hide.length>0)
            hide=hide.substring(1);
          
          this.setAttribute("hide",hide);
        ]]>
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
          if (!this.showPreviews)
            return;
            
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
            previews[i].redraw();
        ]]>
        </body>
      </method>
      
      <method name="displayContextMenu">
        <parameter name="preview"/>
        <parameter name="x"/>
        <parameter name="y"/>
        <body>
          var tab = preview.tab;
          this.tabbrowser.ownerDocument.popupNode = tab;
          var context = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"anonid","tabContextMenu");
          context.showPopup(tab,x,y,"context");
        </body>
      </method>
      
      <!-- Start of DnD implementation -->

      <field name="_lastDrop"/>
      
      <method name="_hideDropIndicator">
        <body>
          if (this._lastDrop)
          {
            this._lastDrop=null;
            this.dragDropBar.setAttribute("dragging","false");
          }
        </body>
      </method>
      
      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
        <![CDATA[
          try
          {
            if (aEvent.target.localName == "tabpreview" &&
                aEvent.originalTarget.localName != "toolbarbutton")
            {
              aXferData.data = new TransferData();
              
              var URI = aEvent.target._browser.currentURI;
              if (URI)
              {
                aXferData.data.addDataForFlavour("text/unicode", URI.spec);
                aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + aEvent.target.title);
                aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + aEvent.target.title + '</a>');
              }
              else
                aXferData.data.addDataForFlavour("text/unicode", "about:blank");
            }
          }
          catch (e)
          {
#ifdef ${extension.debug}
            dump(e);
#endif
          }
        ]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (this.checkDragScroll(aEvent))
              return;
              
            if (!aDragSession.canDrop)
            {
              this._hideDropIndicator();
              return;
            }
              
            if (aDragSession.sourceNode &&
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var newpos = this.getDropElement(aEvent,false);

              var preview = null;
              if (aDragSession.sourceNode.parentNode == this)
                preview = aDragSession.sourceNode;              
              else
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              
              if (newpos == preview.previousSibling || newpos == preview.nextSibling)
              {
                aDragSession.canDrop=false;
                this._hideDropIndicator();
              }
              else
                this._drawDropIndicator(newpos);
            }
            else
            {
              if (aEvent.target.localName=="tabpreview")
                this._drawDropIndicator(aEvent.target);
              else
              {
                var newpos = this.getDropElement(aEvent,true);
                this._drawDropIndicator(newpos);
              }
            }
          }
          catch (e)
          {
#ifdef ${extension.debug}
            dump(e+"\n");
#endif
          }
        ]]>
        </body>
      </method>

      <method name="movePreview">
        <parameter name="preview"/>
        <parameter name="insertBefore"/>
        <body>
        <![CDATA[
          var newIndex = this.previews.length;
          if (insertBefore)
            newIndex = insertBefore.tab._tPos;
          
          var oldIndex = preview.tab._tPos;
          
          if (newIndex>oldIndex)
            newIndex--;
            
          if (newIndex==oldIndex)
            return;

          var focus=false;
          if (this.ownerDocument.commandDispatcher.focusedElement && this.ownerDocument.commandDispatcher.focusedElement==preview)
            focus=true;
          
          this.tabbrowser.moveTabTo(preview.tab, newIndex);
          preview.focus();
        ]]>
        </body>
      </method>
      
      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            this._hideDropIndicator();
            if (aDragSession.sourceNode && 
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var preview = null
              if (aDragSession.sourceNode.parentNode == this)
                preview = aDragSession.sourceNode;              
              else
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              
              var target = this.getDropElement(aEvent,false);
              this.movePreview(preview,target.nextSibling);
            }
            else
            {
              var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);
  
              // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
              // Also disallow dropping javascript: or data: urls--bail out
              if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
                  /^\s*(javascript|data):/.test(url))
                return;
  
              this.tabbrowser.dragDropSecurityCheck(aEvent, aDragSession, url);
  
              var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                    .getService(Components.interfaces.nsIPrefBranch);
              var bgLoad = true;
              try
              {
                bgLoad = prefs.getBoolPref("browser.tabs.loadInBackground");
              }
              catch (e) { }
  
              if (aEvent.shiftKey)
                bgLoad = !bgLoad;
  
              if (aEvent.target.localName != "tabpreview")
              {
#ifdef ${extension.debug}
                this._logMessage("Adding new tab: "+bgLoad);
                
#endif
                // We're adding a new tab.
                var move = false;
                var newIndex = this.previews.length;
                var target = this.getDropElement(aEvent,false);
                if (target.nextSibling)
                {
                  target = target.nextSibling;
                  newIndex = target.tab._tPos;
                  move = true;
                }
  
                var newtab = this.tabbrowser.loadOneTab(url, null, null, null, bgLoad);
                
                if (move)
                  this.tabbrowser.moveTabTo(newtab, newIndex);
                
                if (bgLoad)
                {
                  var preview = this.getPreviewForBrowser(newtab.linkedBrowser);
                  
                  this.ensureElementsAreVisible(preview,preview);
                }
              }
              else
              {
                // Load in an existing tab.
                var preview = aEvent.target;
                preview.browser.loadURI(url);
  
                if (!bgLoad)
                  this.tabbrowser.selectedTab = preview.tab;
              }
            }
          }
          catch (e)
          {
#ifdef ${extension.debug}
            this._logError(e);
#endif
          }
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (!aEvent.relatedTarget && this._lastDrop)
              this._hideDropIndicator();
          }
          catch (e)
          {
#ifdef ${extension.debug}
            dump(e);
#endif
          }
        ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("text/x-moz-url");
          flavourSet.appendFlavour("text/unicode");
          flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
          return flavourSet;
        ]]>
        </body>
      </method>
      
      <method name="_updateSize">
        <body>
        <![CDATA[
          this._validateTimer.cancel();
#ifdef ${extension.debug}
          this._logMessage("Checking for new size");
#endif
          if (this._selected && ((this._browserWidth <= MINBROWSERSIZE) || (this._browserHeight <= MINBROWSERSIZE)))
          {
            this._selected._browserResized();
            this._browserWidth = this._selected._browserWidth;
            this._browserHeight = this._selected._browserHeight;
#ifdef ${extension.debug}
            this._logMessage("Found a browser size of "+this._browserWidth+"x"+this._browserHeight);
#endif
          }
          if (this._selected && (this._browserWidth > MINBROWSERSIZE) && (this._browserHeight > MINBROWSERSIZE) && this._calculateSize())
          {
            this._contentWidth=Math.max(this.displayWidth, 500);
            this._contentHeight=(this.displayHeight/this.displayWidth)*this._contentWidth;
            this._resize();
            this.style.visibility=null;
            this._selected.redraw();
            this._validateMax = this.previews.length;
            if (this._validateMax <= 1)
              return;

            this._validatePos = 0;
          }
          this._validateTimer.initWithCallback(this, this._validateRate, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
        ]]>
        </body>
      </method>
      
      <method name="browserResized">
        <parameter name="preview"/>
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
          if (preview == this._selected)
          {
#ifdef ${extension.debug}
            this._logMessage("Got told a new size of "+width+"x"+height);
#endif
            if ((width != this._browserWidth) || (height != this._browserHeight))
            {
              this._browserWidth = width;
              this._browserHeight = height;
              this._updateSize();
            }
            else if (this.showPreviews)
              preview.redraw();
          }
        </body>
      </method>

      <method name="_validate">
        <body>
        <![CDATA[
          if (this._browserHeight < MINBROWSERSIZE)
            this._updateSize();
          else
          {
            while ((this._validatePos < this._validateMax) && (!this.previews[this._validatePos]._invalid))
              this._validatePos++;
            
            if (this._validatePos >= this._validateMax)
              return;
            
#ifdef ${extension.debug}
            this._logMessage("Updating "+this._validatePos);
#endif
            this.previews[this._validatePos].redraw();
            this._validatePos++;
            
            this._validateTimer.cancel();
            this._validateTimer.initWithCallback(this, this._validateRate, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
          }
        ]]>
        </body>
      </method>
      
      <method name="onPreviewSelect">
        <parameter name="preview"/>
        <body>
          if (this.tabbrowser.selectedTab != preview.tab)
            this.tabbrowser.selectedTab = preview.tab;
          else
            this.ensureElementsAreVisible(preview.previousSibling, preview.nextSibling);
        </body>
      </method>
      
      <method name="dispatchCloneMouseEvent">
      	<parameter name="event"/>
      	<body>
          var target = this.getDropElement(event, false);
          if (target.nextSibling)
          {
            this._newTabPosition = target.nextSibling;
#ifdef ${extension.debug}
            this._logMessage("Potential new tab open at "+this._newTabPosition.tab._tPos);
#endif
          }

	    		target = this.previews[0].tab.boxObject.parentBox;
	    		var ev = this.tabbrowser.ownerDocument.createEvent("MouseEvent");
	    		ev.initMouseEvent(event.type, true, true, this.window,
	    		                  event.detail, event.screenX, event.screenY, event.clientX, event.clientY,
	    		                  event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, null);
	    		target.dispatchEvent(ev);
          this._newTabPosition = null;
      	</body>
      </method>
      
      <method name="onClick">
        <parameter name="event"/>
        <body>
        	if (event.button == 2)
        	{
	          var x = event.screenX-this.window.document.documentElement.boxObject.screenX;
	          var y = event.screenY-this.window.document.documentElement.boxObject.screenY;
	
	          x+=2;
	          y+=2;
	          
	          if (event.target.localName == "tabpreview")
	            this.displayContextMenu(event.target,x,y);
	          else if (this._selected)
	            this.displayContextMenu(this._selected,x,y);
	          else
	            this.displayContextMenu(this.previews[0],x,y);
	        }
          else if ((event.target.localName=="separator" || event.target == this.scrollBox))
	        	this.dispatchCloneMouseEvent(event);
        </body>
      </method>
      
      <method name="onDblClick">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if ((event.target.localName=="separator" || event.target == this.scrollBox))
          	this.dispatchCloneMouseEvent(event);
        ]]>
        </body>
      </method>
      
      <method name="onPreviewTooltipShowing">
        <parameter name="event"/>
        <body>
        <![CDATA[
          var preview = this.ownerDocument.tooltipNode;
          while (preview.localName!="tabpreview")
            preview=preview.parentNode;
          event.originalTarget.childNodes[0].value=preview.title;
          event.originalTarget.childNodes[1].value=preview.uri;
          
          var width = 300;
          if (this.showPreviews && preview.canvas.toDataURL)
          {
            var image = event.originalTarget.childNodes[2];
            image.width=width;
            image.height=(this.contentHeight/this.contentWidth)*width;
            image.src=preview.canvas.toDataURL();
          }
          else
          {
            var height = (this._browserHeight/this._browserWidth)*width;
            
            var canvas = event.originalTarget.childNodes[3];
            canvas.width=width;
            canvas.style.width=width+"px";
            canvas.style.minWidth=width+"px";
            canvas.style.maxWidth=width+"px";
            canvas.height=height;
            canvas.style.height=height+"px";
            canvas.style.minHeight=height+"px";
            canvas.style.maxHeight=height+"px";
            
            var ctx = null;
            try
            {
              ctx = canvas.getContext("2d");
            }
            catch (e)
            {
              canvas.style.display="none";
              return;
            }
            if ((preview._browser)&&(preview._browser.docShell))
            {
              var win = preview._browser.contentWindow;
              var winwidth = this._browserWidth;
              var scaling = width/winwidth;
              var winheight = Math.round(height/scaling);
              ctx.save();
              ctx.scale(scaling,height/winheight);
              try
              {
                var top = 0;
                var left = 0;
                if (this.previews.drawScrolled)
                {
                  top=win.scrollY;
                  left=win.scrollX;
                }
                ctx.drawWindow(win,left,top,winwidth,winheight,"rgba(255,255,255,255)");
                canvas.style.display="";
              }
              catch (e)
              {
                canvas.style.display="none";
#ifdef ${extension.debug}
                dump(e+"\n");
                dump(win+" "+width+"x"+height+"\n");
#endif
              }
              ctx.restore();
            }
            else
              canvas.style.display="none";
          }
        ]]>
        </body>
      </method>

      <!-- Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._validateTimer)
            this._validate();
        ]]>
        </body>
      </method>
      
      <!-- Start of nsIObserver implementation -->

      <method name="observe">
        <parameter name="subject"/>
        <parameter name="topic"/>
        <parameter name="data"/>
        <body>
        <![CDATA[
          switch (data)
          {
            case "content.navigation":
              this._showNavigation = this.preferences.getBoolPref(data);
              this.updateContent();
              break;
            case "content.previews":
              for (var i = 0; i < this.previews.length; i++)
                this.previews[i]._removeListeners();
              this._showPreviews = this.preferences.getBoolPref(data);
              this.updateContent();
              for (var i = 0; i < this.previews.length; i++)
              {
                this.previews[i]._addListeners();
                if (this.updatePreviews)
                  this.previews[i]._checkDocuments("");
              }
              this._updateSize();
              break;
            case "updatepreviews":
              var previous = this.updatePreviews;
              if (this.showPreviews)
              {
                for (var i = 0; i < this.previews.length; i++)
                {
                  this.previews[i]._removeListeners();
                  this.previews[i]._emptyDocumentListeners();
                }
                this._updatePreviews = this.preferences.getBoolPref(data);
                for (var i = 0; i < this.previews.length; i++)
                {
                  this.previews[i]._addListeners();
                  if (this.updatePreviews)
                    this.previews[i]._checkDocuments("");
                }
              }
              else
                this._updatePreviews = this.preferences.getBoolPref(data);
              break;
            case "scrollselects":
              this._scrollSelects = this.preferences.getBoolPref(data);
              break;
              
#ifdef ${extension.debug}
            case "enablelogging":
              this._enableLogging = this.preferences.getBoolPref(data);
              break;
#endif
            case "validaterate":
              this._validateRate = this.preferences.getIntPref(data);
              break;
            case "loadrefresh":
              this._loadRefresh = this.preferences.getBoolPref(data);
              break;
            case "loadrefreshrate":
              this._loadRefreshRate = this.preferences.getIntPref(data);
              break;
            case "loaderrordelay":
              this._loadErrorDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedloaderrordelay":
              this._unselectedLoadErrorDelay = this.preferences.getIntPref(data);
              break;
            case "loaddelay":
              this._loadDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedloaddelay":
              this._unselectedLoadDelay = this.preferences.getIntPref(data);
              break;
            case "scrolldelay":
              this._scrollDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedscrolldelay":
              this._unselectedScrollDelay = this.preferences.getIntPref(data);
              break;
            case "textdelay":
              this._textDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedtextdelay":
              this._unselectedTextDelay = this.preferences.getIntPref(data);
              break;
            case "changedelay":
              this._changeDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedchangedelay":
              this._unselectedChangeDelay = this.preferences.getIntPref(data);
              break;
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      
      <handler event="DOMMouseScroll">
      <![CDATA[
      	if (this.scrollSelects)
      	{
	      	var target;
      		if (event.detail<0)
	          target = this._selected.previousSibling.previousSibling;
	        else
	          target = this._selected.nextSibling.nextSibling;
	        
	        if (target)
	        	this.tabbrowser.selectedTab = target.tab;
      	}
      	else
	        this.scrollBy(event.detail);
	    ]]>
      </handler>
      
      <handler event="scroll">
        this._updateScrollButtons();
      </handler>
      
      <handler event="focus">
        if (event.originalTarget==this.focusDetector)
        {
          if (this._selected)
            this._selected.focus();
        }
        else if (event.target.parentNode==this)
          this.focusDetector.style.MozUserFocus="ignore";
      </handler>
      
      <handler event="blur">
        if (event.target.parentNode==this)
          this.focusDetector.style.MozUserFocus="normal";
      </handler>
      
    </handlers>

  </binding>
  
</bindings>
