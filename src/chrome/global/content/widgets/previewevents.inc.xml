      <field name="_eventListener"/>
      <field name="CHANGE_LOAD">1</field>
      <field name="CHANGE_TEXT">2</field>
      <field name="CHANGE_DOCUMENT">4</field>
      <field name="CHANGE_SCROLL">8</field>
      <field name="_changeTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      <field name="_changeTime">0</field>
      <field name="_changeReason">0</field>
      <field name="_listenedDocuments">[]</field>
                  
      <field name="_timerListener">({
          tabpreview: this,

          notify : function(timer)
          {
            if (this.tabpreview)
              this.tabpreview.notify(timer);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsITimerCallback) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      
      <method name="_addListeners">
        <body>
          //this._logMessage("Add browser listeners");
          
          this._browser.addEventListener("DOMTitleChanged",      this._eventListener, false);
          this._browser.addEventListener("resize",               this._eventListener, false);
          this._browser.addEventListener("scroll",               this._eventListener, true);
          this._browser.addEventListener("load",                 this._eventListener, true);
          this._browser.addEventListener("unload",               this._eventListener, true);
          this._browser.addEventListener("pageshow",             this._eventListener, true);
          this._browser.addEventListener("pagehide",             this._eventListener, true);
          var WP = Components.interfaces.nsIWebProgress;
          var mask = WP.NOTIFY_ALL;
          if (this._browser.docShell)
          {
            this._browser.webProgress.addProgressListener(this._progressListener,mask);
            //this._browser.sessionHistory.addSHistoryListener(this._historyListener);
          }
          else
          {
            this._logError("Could not register browser progress listener");
          }
          WP=null;
          mask=null;
        </body>
      </method>
      
      <method name="_removeListeners">
        <body>
          try
          {
            //this._logMessage("Remove browser listeners");
          
            this._browser.removeEventListener("DOMTitleChanged", this._eventListener, false);
            this._browser.removeEventListener("resize",          this._eventListener, false);
            this._browser.removeEventListener("scroll",          this._eventListener, true);
            this._browser.removeEventListener("load",            this._eventListener, true);
            this._browser.removeEventListener("unload",          this._eventListener, true);
            this._browser.removeEventListener("pageshow",        this._eventListener, true);
            this._browser.removeEventListener("pagehide",        this._eventListener, true);
            if (this._browser.docShell)
            {
              this._browser.webProgress.removeProgressListener(this._progressListener);
              //this._browser.sessionHistory.removeSHistoryListener(this._historyListener);
            }
            else
            {
              this._logWarning("Could not unregister browser progress listener");
            }
          }
          catch (e)
          {
            dump(e+"\n");
          }
        </body>
      </method>
      
      <method name="_addDocumentListeners">
      	<parameter name="doc"/>
        <body>
        <![CDATA[
          var pos = this._listenedDocuments.indexOf(doc);
          if (pos<0)
          {
            this._logMessage("Adding document "+doc.location.href);
            
            doc.addEventListener("DOMNodeInserted",                this._eventListener, true);
            doc.addEventListener("DOMNodeRemoved",                 this._eventListener, true);
            doc.addEventListener("DOMNodeRemovedFromDocument",     this._eventListener, true);
            doc.addEventListener("DOMNodeInsertedIntoDocument",    this._eventListener, true);
            doc.addEventListener("DOMAttrModified",                this._eventListener, true);
            doc.addEventListener("DOMCharacterDataModified",       this._eventListener, true);
            doc.addEventListener("DOMElementNameChanged",          this._eventListener, true);
            doc.addEventListener("DOMAttributeNameChanged",        this._eventListener, true);
            doc.addEventListener("DOMActivate",                    this._eventListener, true);
            doc.addEventListener("DOMFocusIn",                     this._eventListener, true);
            doc.addEventListener("DOMFocusOut",                    this._eventListener, true);
            doc.addEventListener("DOMSubtreeModified",             this._eventListener, true);
            doc.addEventListener("scroll",                         this._eventListener, true);
            this._listenedDocuments.push(doc);
            
            this._logMessage("Listening to "+this._listenedDocuments.length+" documents");
          }
          else
          {
            //this._logMessage("Listeners already added\n");
          }
        ]]>
        </body>
      </method>
      
      <method name="_removeDocumentListeners">
        <parameter name="doc"/>
        <body>
        <![CDATA[
          var pos = this._listenedDocuments.indexOf(doc);
          if (pos>=0)
          {
            this._logMessage("Removing document "+doc.location.href);
            
            doc.removeEventListener("DOMNodeInserted",             this._eventListener, true);
            doc.removeEventListener("DOMNodeRemoved",              this._eventListener, true);
            doc.removeEventListener("DOMNodeRemovedFromDocument",  this._eventListener, true);
            doc.removeEventListener("DOMNodeInsertedIntoDocument", this._eventListener, true);
            doc.removeEventListener("DOMAttrModified",             this._eventListener, true);
            doc.removeEventListener("DOMCharacterDataModified",    this._eventListener, true);
            doc.removeEventListener("DOMElementNameChanged",       this._eventListener, true);
            doc.removeEventListener("DOMAttributeNameChanged",     this._eventListener, true);
            doc.removeEventListener("DOMActivate",                 this._eventListener, true);
            doc.removeEventListener("DOMFocusIn",                  this._eventListener, true);
            doc.removeEventListener("DOMFocusOut",                 this._eventListener, true);
            doc.removeEventListener("DOMSubtreeModified",          this._eventListener, true);
            doc.removeEventListener("scroll",                      this._eventListener, true);
            this._listenedDocuments.splice(pos,1);
            
            this._logMessage("Listening to "+this._listenedDocuments.length+" documents");
          }
          else
          {
            //this._logMessage("Listeners already removed\n");
          }
        ]]>
        </body>
      </method>
      
      <method name="_emptyDocumentListeners">
        <body>
        <![CDATA[
          while (this._listenedDocuments.length>0)
          {
            this._removeDocumentListeners(this._listenedDocuments[0]);
          }
        ]]>
        </body>
      </method>
      
      <method name="_findDocuments">
      	<parameter name="doc"/>
        <parameter name="newdocs"/>
      	<body>
      	<![CDATA[
      		if (doc)
      		{
            if (doc.contentDocument && (doc.contentDocument instanceof Document))
              doc=doc.contentDocument;

            if ((doc instanceof Document)&&(newdocs.indexOf(doc)==-1))
              newdocs.push(doc);

            if (doc.getElementsByTagName)
            {
  	      		var subdocs = doc.getElementsByTagName("frame");
  	      		for (var pos = 0; pos<subdocs.length; pos++)
  	      		{
                this._logMessage("Adding new frame");
        				this._findDocuments(subdocs[pos].contentDocument, newdocs);
  	      		}
  	      		subdocs = doc.getElementsByTagName("iframe");
  	      		for (var pos = 0; pos<subdocs.length; pos++)
  	      		{
                this._logMessage("Adding new iframe");
        				this._findDocuments(subdocs[pos].contentDocument, newdocs);
  	      		}
  	      		subdocs = doc.getElementsByTagName("browser");
  	      		for (var pos = 0; pos<subdocs.length; pos++)
  	      		{
                this._logMessage("Adding new browser");
        				this._findDocuments(subdocs[pos].contentDocument, newdocs);
  	      		}
            }
	      	}
          else
          {
            this._logWarning("Attempt to add null doc");
          }
				]]>
      	</body>
      </method>
      
      <method name="_checkDocuments">
        <parameter name="reason"/>
        <body>
        <![CDATA[
          if ((!this._browser)||(!this._browser.docShell))
            return;
            
          if (this._listenedDocuments.length>0)
          {
            if (this._listenedDocuments.indexOf(this._browser.contentDocument)>=0)
              return;
          }
          
          var newdocs = [];
          this._findDocuments(this._browser.contentDocument, newdocs);
          
          var target = newdocs.length;
          
          this._logMessage("checkDocuments");
          
          var lost = this._listenedDocuments.length;
          var pos=0;
          while (pos<this._listenedDocuments.length)
          {
            var fpos = newdocs.indexOf(this._listenedDocuments[pos]);
            if (fpos>=0)
            {
              this._logMessage("kept "+this._listenedDocuments[pos].location.href);
              newdocs.splice(fpos,1);
              pos++;
            }
            else
            {
              this._logMessage("lost "+this._listenedDocuments[pos].location.href);
              this._removeDocumentListeners(this._listenedDocuments[pos]);
            }
          }

          lost-=this._listenedDocuments.length;
          this._logWarning("Bad document tree detected from "+reason+": lost "+lost+" documents, gained "+newdocs.length+" documents, kept "+this._listenedDocuments.length+" documents.");

          for (var i=0; i<newdocs.length; i++)
          {
            this._addDocumentListeners(newdocs[i]);
            this._logMessage("gained "+this._listenedDocuments[pos].location.href);
          }
          
          if (this._listenedDocuments.length!=target)
          {
            this._logWarning("checkDocuments failure: "+target+" -> "+this._listenedDocuments.length);
          }
          
          this._documentLoaded();
        ]]>
        </body>
      </method>
      
      <method name="_startTimer">
        <parameter name="reason"/>
        <parameter name="selectedDelay"/>
        <parameter name="unselectedDelay"/>
        <body>
        <![CDATA[
          var delay = selectedDelay;
          
          if (!this.selected)
            delay = unselectedDelay;

          var date = Date.now()+delay;
          
          this._changeReason|=reason;

          if (date>this._changeTime)
          {
            this._changeTimer.cancel();
            this._changeTimer.initWithCallback(this._timerListener, delay, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
            this._changeTime=date;
          }
        ]]>
        </body>
      </method>
      
      <method name="_updateSize">
        <parameter name="forceRedraw"/>
        <body>
        <![CDATA[
          var width = this._browser.parentNode.boxObject.width;
          var height = this._browser.parentNode.boxObject.height;
          
          var findbar = this._browser.ownerDocument.getElementById("FindToolbar");
          if (!findbar.hidden)
          {
            height+=findbar.boxObject.height;
          }
          
          this._logMessage("new size: "+width+"x"+height);
          var shouldRedraw = forceRedraw || this._browserWidth != width || this._browserHeight != height;
          
          this._browserWidth = width;
          this._browserHeight = height;
          this.previews.browserResized(this,this._browserWidth,this._browserHeight);
          if (shouldRedraw)
          {
            this.redraw();
            return true;
          }
          return false;
        ]]>
        </body>
      </method>
            
      <method name="_documentLoaded">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer(this.CHANGE_LOAD, this.previews.loadDelay, this.previews.unselectedLoadDelay);
        </body>
      </method>
      
      <method name="_documentTextInput">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer(this.CHANGE_TEXT, this.previews.textDelay, this.previews.unselectedTextDelay);
        </body>
      </method>
      
      <method name="_documentChanged">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer(this.CHANGE_DOCUMENT, this.previews.changeDelay, this.previews.unselectedChangeDelay);
        </body>
      </method>
      
      <method name="_documentScrolled">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer(this.CHANGE_SCROLL, this.previews.scrollDelay, this.previews.unselectedScrollDelay);
        </body>
      </method>
      
      <method name="_eventFilter">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if (!this.previews)
            return;
          
          try
          {
            //this._logMessage("Event - "+event.type);
            if (event.type=="DOMTitleChanged")
            {
              this.onTitleChange();
            }
            else if (event.type=="resize")
            {
              this._logMessage("Browser resized");
              this._updateSize(false);
            }
            else if ((event.type=="load")||(event.type=="pageshow"))
            {
              var doc = null;
              if (event.target)
              {
                if (event.target instanceof Document)
                {
                  doc=event.target;
                }
                else if (event.target.document)
                {
                  doc=event.target.document;
                }
                else if (event.target.contentDocument)
                {
                  doc=event.target.contentDocument;
                }
                else if (event.target.ownerDocument.documentElement==event.target)
                {
                  doc=event.target.ownerDocument;
                }
              }
              
              if (doc)
              {
                this._addDocumentListeners(doc);
              }
              else
              {
                this._logWarning(event.type+" from unknown place: "+event.target+" "+event.originalTarget);
              }
              this._documentLoaded();
            }
            else if ((event.type=="unload")||(event.type=="pagehide"))
            {
              var doc = null;
              if (event.target)
              {
                if (event.target instanceof Document)
                {
                  doc=event.target;
                }
                else if (event.target.document)
                {
                  doc=event.target.document;
                }
                else if (event.target.contentDocument)
                {
                  doc=event.target.contentDocument;
                }
                else if (event.target.ownerDocument.documentElement==event.target)
                {
                  doc=event.target.ownerDocument;
                }
              }
              
              if (doc)
              {
                this._removeDocumentListeners(doc);
              }
              else
              {
                this._logWarning(event.type+" from unknown place: "+event.target);
              }
            }
            else if (this._listenedDocuments.indexOf(event.target.ownerDocument)>=0)
            {
              if (event.type=="scroll")
              {
                this._documentScrolled();
              }
              else if ((event.type.substring(0,3)=="DOM")&&(!this.loading))
              {
                if (event.type=="DOMAttrModified")
                {
                  if ((event.attrName=="maxpos")||(event.attrName=="pageincrement"))
                  {
                      return;
                  }
                  else if (event.attrName=="curpos")
                  {
                      this._documentScrolled();
                      return;
                  }
                }
                else if ((event.type=="DOMNodeInserted")||(event.type=="DOMNodeInsertedIntoDocument")||(event.type=="DOMCharacterDataModified"))
                {
                  if (event.target instanceof HTMLTextAreaElement)
                  {
                    this._documentTextInput();
                    return;
                  }
                  if (event.target instanceof HTMLInputElement)
                  {
                    if ((event.target.type=="text")||(event.target.type=="password"))
                    {
                      this._documentTextInput();
                      return;
                    }
                  }
                }
                this._documentChanged();
              }
            }
          }
          catch (e)
          {
            this._logWarning(e);
          }
        ]]>
        </body>
      </method>
      
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if ((!this.previews)||(!this._browser))
            return;
          
          if (timer==this._updateTimer)
          {
            //this.update();
            if (this._invalid)
            {
              this._redraw();
              this._invalid=false;
            }
            return;
          }
          
          this._logMessage("Timer fired - "+this._changeReason);
          
          this.redraw();

          if (this._changeReason & this.CHANGE_LOAD)
            this.update();
            
          this._changeReason=0;
        ]]>
        </body>
      </method>
      
      