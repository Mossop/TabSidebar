# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Tab Sidebar Display.
#
# The Initial Developer of the Original Code is
#      Dave Townsend <dtownsend@oxymoronical.com>.
#
# Portions created by the Initial Developer are Copyright (C) 2007
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
      <field name="CHANGE_LOAD">1</field>
      <field name="CHANGE_TEXT">2</field>
      <field name="CHANGE_SCROLL">4</field>
      <field name="CHANGE_OTHER">128</field>
      <field name="_changeTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      <field name="_changeTime">0</field>
      <field name="_changeReason">0</field>
      <field name="_listenedDocuments">[]</field>

      <field name="_timerListener">
      ({
        tabpreview: this,

        notify : function(timer) {
          if (this.tabpreview)
            this.tabpreview.notify(timer);
        },

        QueryInterface : function(aIID) {
          if (aIID.equals(Components.interfaces.nsITimerCallback) ||
              aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
              aIID.equals(Components.interfaces.nsISupports))
            return this;
          throw Components.results.NS_NOINTERFACE;
        }
      });
      </field>

      <method name="_addListeners">
        <body>
#ifdef ${extension.debug}
          this._logMessage("Add browser listeners");

#endif
          this._browser.addEventListener("DOMTitleChanged",        this._browserListener, false);
          this._browser.addEventListener("load",                   this._browserListener, true);
          this._browser.addEventListener("pageshow",               this._browserListener, true);
          this._browser.addEventListener("pagehide",               this._browserListener, true);
          this._browser.addEventListener("resize",                 this._browserListener, false);

          const mask = Components.interfaces.nsIWebProgress.NOTIFY_ALL;
          if (this._browser.docShell)
            this._browser.webProgress.addProgressListener(this._progressListener, mask);
#ifdef ${extension.debug}
          else
            this._logError("Could not register browser progress listener");
#endif
        </body>
      </method>

      <method name="_removeListeners">
        <body>
          try {
#ifdef ${extension.debug}
            this._logMessage("Remove browser listeners");

#endif
            this._browser.removeEventListener("DOMTitleChanged",   this._browserListener, false);
            this._browser.removeEventListener("load",              this._browserListener, true);
            this._browser.removeEventListener("pageshow",          this._browserListener, true);
            this._browser.removeEventListener("pagehide",          this._browserListener, true);
            this._browser.removeEventListener("resize",            this._browserListener, false);

            if (this._browser.docShell)
              this._browser.webProgress.removeProgressListener(this._progressListener);
#ifdef ${extension.debug}
            else
              this._logWarning("Could not unregister browser progress listener");
#endif
          }
          catch (e) {
#ifdef ${extension.debug}
            this._logError("Error removing listeners from tab: "+e);
            dump(e+"\n");
#endif
          }
        </body>
      </method>

      <method name="_addDocumentListeners">
        <parameter name="doc"/>
        <body>
        <![CDATA[
          var pos = this._listenedDocuments.indexOf(doc);
          if (pos >= 0)
            return;

          this._listenedDocuments.push(doc);
#ifdef ${extension.debug}
          this._logMessage("Adding document " + doc.location.href);
          this._logMessage("Now listening to " + this._listenedDocuments.length + " documents");
#endif

          if (!this.showPreview)
            return;

          if (this.previews.updatePreviews) {
            doc.addEventListener("DOMNodeInserted",                this._eventListener, true);
            doc.addEventListener("DOMNodeRemoved",                 this._eventListener, true);
            doc.addEventListener("DOMNodeRemovedFromDocument",     this._eventListener, true);
            doc.addEventListener("DOMNodeInsertedIntoDocument",    this._eventListener, true);
            doc.addEventListener("DOMAttrModified",                this._eventListener, true);
            doc.addEventListener("DOMCharacterDataModified",       this._eventListener, true);
            doc.addEventListener("DOMElementNameChanged",          this._eventListener, true);
            doc.addEventListener("DOMAttributeNameChanged",        this._eventListener, true);
            doc.addEventListener("DOMActivate",                    this._eventListener, true);
            doc.addEventListener("DOMFocusIn",                     this._eventListener, true);
            doc.addEventListener("DOMFocusOut",                    this._eventListener, true);
            doc.addEventListener("DOMSubtreeModified",             this._eventListener, true);
            doc.addEventListener("scroll",                         this._eventListener, true);
          }
        ]]>
        </body>
      </method>

      <method name="_removeDocumentListeners">
        <parameter name="doc"/>
        <body>
        <![CDATA[
          var pos = this._listenedDocuments.indexOf(doc);
          if (pos < 0)
            return;

#ifdef ${extension.debug}
          if (doc.location)
            this._logMessage("Removing document "+doc.location.href);
          else
            this._logWarning("Removing expired document");

#endif
          this._listenedDocuments.splice(pos,1);
#ifdef ${extension.debug}
          this._logMessage("Now listening to "+this._listenedDocuments.length+" documents");
#endif

          doc.removeEventListener("DOMNodeInserted",             this._eventListener, true);
          doc.removeEventListener("DOMNodeRemoved",              this._eventListener, true);
          doc.removeEventListener("DOMNodeRemovedFromDocument",  this._eventListener, true);
          doc.removeEventListener("DOMNodeInsertedIntoDocument", this._eventListener, true);
          doc.removeEventListener("DOMAttrModified",             this._eventListener, true);
          doc.removeEventListener("DOMCharacterDataModified",    this._eventListener, true);
          doc.removeEventListener("DOMElementNameChanged",       this._eventListener, true);
          doc.removeEventListener("DOMAttributeNameChanged",     this._eventListener, true);
          doc.removeEventListener("DOMActivate",                 this._eventListener, true);
          doc.removeEventListener("DOMFocusIn",                  this._eventListener, true);
          doc.removeEventListener("DOMFocusOut",                 this._eventListener, true);
          doc.removeEventListener("DOMSubtreeModified",          this._eventListener, true);
          doc.removeEventListener("scroll",                      this._eventListener, true);
        ]]>
        </body>
      </method>

      <method name="_emptyDocumentListeners">
        <body>
        <![CDATA[
          while (this._listenedDocuments.length > 0)
            this._removeDocumentListeners(this._listenedDocuments[0]);
        ]]>
        </body>
      </method>

      <method name="updateDocumentListeners">
        <body>
        <![CDATA[
          var docs = this._listenedDocuments.slice(0);
          this._emptyDocumentListeners();
          for (var i = 0; i < docs.length; i++)
            this._addDocumentListeners(docs[i]);
        ]]>
        </body>
      </method>

      <method name="_findDocuments">
        <parameter name="doc"/>
        <parameter name="newdocs"/>
        <body>
        <![CDATA[
          if (!doc) {
#ifdef ${extension.debug}
            this._logWarning("Attempt to add null doc");
#endif
            return;
          }

          if (doc.contentDocument && (doc.contentDocument instanceof Document))
            doc=doc.contentDocument;

          if ((doc instanceof Document) && (newdocs.indexOf(doc) == -1))
            newdocs.push(doc);

          if (doc.getElementsByTagName) {
            var subdocs = doc.getElementsByTagName("frame");
            for (var pos = 0; pos < subdocs.length; pos++) {
#ifdef ${extension.debug}
              this._logMessage("Adding new frame");
#endif
              this._findDocuments(subdocs[pos].contentDocument, newdocs);
            }
            subdocs = doc.getElementsByTagName("iframe");
            for (var pos = 0; pos < subdocs.length; pos++) {
#ifdef ${extension.debug}
              this._logMessage("Adding new iframe");
#endif
              this._findDocuments(subdocs[pos].contentDocument, newdocs);
            }
            subdocs = doc.getElementsByTagName("browser");
            for (var pos = 0; pos < subdocs.length; pos++) {
#ifdef ${extension.debug}
              this._logMessage("Adding new browser");
#endif
              this._findDocuments(subdocs[pos].contentDocument, newdocs);
            }
          }
        ]]>
        </body>
      </method>

      <method name="_checkDocuments">
        <parameter name="reason"/>
        <body>
        <![CDATA[
          if ((!this._browser) || (!this._browser.docShell))
            return;

          if (this._listenedDocuments.length > 0) {
            if (this._listenedDocuments.indexOf(this._browser.contentDocument)>=0)
              return;
          }

          var newdocs = [];
          this._findDocuments(this._browser.contentDocument, newdocs);

          var target = newdocs.length;

#ifdef ${extension.debug}
          this._logMessage("checkDocuments");

#endif
          var lost = this._listenedDocuments.length;
          var pos=0;
          while (pos < this._listenedDocuments.length) {
            var fpos = newdocs.indexOf(this._listenedDocuments[pos]);
            if (fpos >= 0) {
#ifdef ${extension.debug}
              this._logMessage("kept "+this._listenedDocuments[pos].location);
#endif
              newdocs.splice(fpos,1);
              pos++;
            }
            else {
#ifdef ${extension.debug}
              this._logMessage("lost "+this._listenedDocuments[pos].location);
#endif
              this._removeDocumentListeners(this._listenedDocuments[pos]);
            }
          }

          lost -= this._listenedDocuments.length;
#ifdef ${extension.debug}
          this._logWarning("Bad document tree detected from "+reason+": lost "+lost+" documents, gained "+newdocs.length+" documents, kept "+this._listenedDocuments.length+" documents.");
#endif

          for (var i = 0; i < newdocs.length; i++) {
            this._addDocumentListeners(newdocs[i]);
#ifdef ${extension.debug}
            this._logMessage("gained " + newdocs[i].location.href);
#endif
          }

#ifdef ${extension.debug}
          if (this._listenedDocuments.length != target)
            this._logWarning("checkDocuments failure: " + target + " -> " + this._listenedDocuments.length);

#endif
          this._documentLoaded();
        ]]>
        </body>
      </method>

      <method name="_startTimer">
        <parameter name="reason"/>
        <parameter name="delay"/>
        <body>
        <![CDATA[
          this._invalid = true;
          var delay = this.selected ? delay.selected : delay.unselected;
          var date = Date.now() + delay;

          this._changeReason |= reason;

          if (date > this._changeTime) {
            this._changeTimer.cancel();
            this._changeTimer.initWithCallback(this._timerListener, delay, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
            this._changeTime = date;
          }
        ]]>
        </body>
      </method>

      <method name="_browserResized">
        <body>
        <![CDATA[
          var width = this._browser.parentNode.parentNode.boxObject.width;
          var height = this._browser.parentNode.parentNode.boxObject.height;

          var findbar = this._browser.ownerDocument.getElementById("FindToolbar");
          if (!findbar.hidden)
            height += findbar.boxObject.height;

#ifdef ${extension.debug}
          this._logMessage("new size: " + width + "x" + height);

#endif
          this._invalid = true;
          this._browserHeight = height;
          this._browserWidth = width;
        ]]>
        </body>
      </method>

      <method name="_documentLoaded">
        <body>
          if (!this.previews)
            return;
          this._startTimer(this.CHANGE_LOAD, this.previews.delays.load);
        </body>
      </method>

      <method name="_documentLoadError">
        <body>
          if (!this.previews)
            return;
          this._startTimer(this.CHANGE_LOAD, this.previews.delays.loadError);
        </body>
      </method>

      <method name="_documentTextInput">
        <body>
          if (!this.previews)
            return;
          this._startTimer(this.CHANGE_TEXT, this.previews.delays.text);
        </body>
      </method>

      <method name="_documentChanged">
        <body>
          if (!this.previews)
            return;
          this._startTimer(this.CHANGE_OTHER, this.previews.delays.change);
        </body>
      </method>

      <method name="_documentScrolled">
        <body>
          if (!this.previews || !this.previews.drawScrolled)
            return;
          this._startTimer(this.CHANGE_SCROLL, this.previews.delays.scroll);
        </body>
      </method>

      <field name="_browserListener">
      <![CDATA[
      ({
        tabpreview: this,

        getDocumentForEvent: function(event) {
          if (event.target) {
            if (event.target instanceof Document)
              return event.target;
            else if (event.target.document)
              return event.target.document;
            else if (event.target.contentDocument)
              return event.target.contentDocument;
            else if (event.target.ownerDocument.documentElement==event.target)
              return event.target.ownerDocument;
          }
          return null;
        },

        handleEvent: function(event) {
          if (this.tabpreview._destroyed)
            return;

          if (!this.tabpreview.previews)
            return;

          try {
#ifdef ${extension.debug}
            //this.tabpreview._logMessage("Event - "+event.type);
#endif
            switch (event.type) {
              case "DOMTitleChanged":
                this.tabpreview.onTitleChange();
                break;
              case "resize":
#ifdef ${extension.debug}
                this.tabpreview._logMessage("Browser resized");
#endif
                this.tabpreview._browserResized();
                this.tabpreview.previews.browserResized(this.tabpreview, this.tabpreview._browserWidth, this.tabpreview._browserHeight);
                break;
              case "load":
              case "pageshow":
#ifdef ${extension.debug}
                this.tabpreview._logMessage("Event - "+event.type);
#endif
                var doc = this.getDocumentForEvent(event);
                if (doc)
                  this.tabpreview._addDocumentListeners(doc);
#ifdef ${extension.debug}
                else
                  this.tabpreview._logWarning(event.type+" from unknown place: "+event.target+" "+event.originalTarget);
#endif
                this.tabpreview._documentLoaded();
                break;
              case "unload":
              case "pagehide":
#ifdef ${extension.debug}
                this.tabpreview._logMessage("Event - "+event.type);
#endif
                var doc = this.getDocumentForEvent(event);
                if (doc)
                  this.tabpreview._removeDocumentListeners(doc);
#ifdef ${extension.debug}
                else
                  this.tabpreview._logWarning(event.type+" from unknown place: "+event.target);
#endif
                break;
            }
          }
          catch (e) {
#ifdef ${extension.debug}
            this.tabpreview._logWarning(e);
#endif
          }
        }
      })
      ]]>
      </field>

      <field name="_eventListener">
      <![CDATA[
      ({
        tabpreview: this,

        handleEvent: function(event) {
          if (this.tabpreview_destroyed)
            return;

          if (!this.tabpreview.previews)
            return;

          try {
#ifdef ${extension.debug}
            //this.tabpreview._logMessage("Event - "+event.type);
#endif
            if (this.tabpreview.loading)
              return;

            var sourcedoc;
            if (event.target instanceof Document)
              sourcedoc = event.target;
            else
              sourcedoc = event.target.ownerDocument;

            if (event.type == "scroll") {
              this.tabpreview._documentScrolled();
            }
            else if (this.tabpreview._listenedDocuments.indexOf(sourcedoc) >= 0) {
              if (event.type.substring(0,3) == "DOM") {
                if (event.type == "DOMAttrModified") {
                  if ((event.attrName == "maxpos") ||
                      (event.attrName == "pageincrement")) {
                    return;
                  }
                  else if (event.attrName == "curpos") {
                    this.tabpreview._documentScrolled();
                    return;
                  }
                }
                else if ((event.type == "DOMNodeInserted") ||
                         (event.type == "DOMNodeInsertedIntoDocument") ||
                         (event.type == "DOMCharacterDataModified")) {
                  if (event.target instanceof HTMLTextAreaElement) {
                    this.tabpreview._documentTextInput();
                    return;
                  }
                  if (event.target instanceof HTMLInputElement) {
                    if ((event.target.type=="text")||(event.target.type=="password")) {
                      this.tabpreview._documentTextInput();
                      return;
                    }
                  }
                }
#ifdef ${extension.debug}
                this.tabpreview._logMessage(event.type);
#endif
                this.tabpreview._documentChanged();
              }
#ifdef ${extension.debug}
              else {
                this.tabpreview._logWarning("Received an unknown event: "+event.type);
              }
#endif
            }
#ifdef ${extension.debug}
            else {
              this.tabpreview._logWarning("Received an event for an unknown document: "+sourcedoc.location.href+" "+event.type);
            }
#endif
          }
          catch (e) {
#ifdef ${extension.debug}
            this.tabpreview._logWarning(e);
#endif
          }
        }
      });
      ]]>
      </field>

      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if ((!this.previews) || (!this._browser))
            return;

          if (timer == this._updateTimer) {
            this.update();
            this.redraw();
            this._changeTimer.cancel();
            this._changeTime = 0;
            this._changeReason = 0;
            return;
          }

          if (this._changeReason) {
#ifdef ${extension.debug}
            this._logMessage("Timer fired - " + this._changeReason);

#endif
            this.redraw();

            if (this._changeReason & this.CHANGE_LOAD)
              this.update();

            this._changeReason = 0;
          }
        ]]>
        </body>
      </method>

