<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings [
<!ENTITY % bidiDTD SYSTEM "chrome://global/locale/global.dtd">
<!ENTITY % tabbrowserDTD SYSTEM "chrome://global/locale/tabbrowser.dtd" >
<!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd" >
<!ENTITY % tabSidebarDTD SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd" >
%bidiDTD;
%tabbrowserDTD;
%browserDTD;
%tabSidebarDTD;
]>

<bindings id="TabSidebarBindings2"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreview" name="tabpreview">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/widgets/tabpreviews.css"/>
    </resources>
    
    <content class="tbs-tabpreview" orient="vertical" align="stretch" loading="false" security="none">
      <xul:vbox class="tbs-tabmain" flex="1">
        <xul:hbox class="tbs-topbox" align="center" anonid="topbox">
          <xul:image class="tbs-favicon" validate="never" anonid="favicon" tooltip="tabpreview_tooltip" onerror="this.src=null;"/>
          <xul:image class="tbs-loading" anonid="loading" tooltip="tabpreview_tooltip"/>
          <xul:label class="tbs-title" tooltip="tabpreview_tooltip" flex="1" anonid="title" crop="end"/>
          <xul:toolbarbutton class="tbs-close tbs-icon" anonid="close" tooltiptext="&closeTab.label;"
                             onmousedown="event.stopPropagation();"
                             oncommand="this.parentNode.parentNode.parentNode.close();"/>
        </xul:hbox>
        <xul:stack flex="1">
          <xul:box tooltip="tabpreview_tooltip" flex="1" class="tbs-container" anonid="canvas_container">
            <xhtml:canvas class="tbs-canvas" flex="1" anonid="canvas" tooltip="tabpreview_tooltip"/>
          </xul:box>
          <xul:vbox>
            <xul:hbox pack="end" class="tbs-topstrip">
              <xul:toolbarbutton class="tbs-security tbs-icon" anonid="security"
                                 onmousedown="event.stopPropagation();"
                                 oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.viewSecurity();"/>
            </xul:hbox>
            <xul:box tooltip="tabpreview_tooltip" flex="1"/>
            <xul:hbox pack="start" class="tbs-bottomstrip">
              <xul:toolbarbutton class="tbs-stop tbs-icon" anonid="stop" disabled="true" tooltiptext="&stopButton.tooltip;"
                                 onmousedown="event.stopPropagation();"
                                 oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.stop();"/>
              <xul:spacer flex="1"/>
              <xul:toolbarbutton chromedir="&locale.dir;" type="menu-button" class="tbs-back tbs-icon" anonid="back" disabled="true" tooltiptext="&backButton.tooltip;"
                                 onmousedown="event.stopPropagation();"
                                 onclick="this.parentNode.parentNode.parentNode.parentNode.parentNode.checkMiddleClick(this,event);"
                                 oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.goBack(event);">
                <xul:menupopup onpopupshowing="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.populateBackMenu(event);"
                               oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.gotoHistoryIndex(event); event.preventBubble()"
                               onclick="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.checkMiddleClick(this,event);"/>
              </xul:toolbarbutton>
              <xul:spacer flex="1"/>
              <xul:toolbarbutton chromedir="&locale.dir;" type="menu-button" class="tbs-forward tbs-icon" anonid="forward" disabled="true" tooltiptext="&forwardButton.tooltip;"
                                 onmousedown="event.stopPropagation();"
                                 onclick="this.parentNode.parentNode.parentNode.parentNode.parentNode.checkMiddleClick(this,event);"
                                 oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.goForward(event);">
                <xul:menupopup onpopupshowing="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.populateForwardMenu(event);"
                               oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.gotoHistoryIndex(event); event.preventBubble()"
                               onclick="this.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.checkMiddleClick(this,event);"/>
              </xul:toolbarbutton>
              <xul:spacer flex="1"/>
              <xul:toolbarbutton class="tbs-reload tbs-icon" anonid="reload" tooltiptext="&reloadButton.tooltip;"
                                 onmousedown="event.stopPropagation();"
                                 oncommand="this.parentNode.parentNode.parentNode.parentNode.parentNode.reload(event);"/>
            </xul:hbox>
          </xul:vbox>
        </xul:stack>
        <xul:vbox class="tbs-bottombox" tooltip="tabpreview_tooltip" align="stretch" anonid="bottombox">
          <xul:label class="tbs-uri" anonid="uri" crop="end"/>
        </xul:vbox>
      </xul:vbox>
    </content>

    <implementation implements="nsIWebProgressListener,nsISHistoryListener,nsITimerCallback">

      <constructor>
      </constructor>

      <destructor>
        dump("Tabpreview destructor\n");
        this._destroy();
      </destructor>
      
      <field name="_destroyed" value="false"/>
      <method name="_destroy">
        <body>
          if (!this._destroyed)
          {
            try
            {
              this._destroyed=true;
              
              if (this._browser)
              {
                this._emptyDocumentListeners();
                this._removeListeners();
                this._browser=null;
              }
  
              //this.loading=false;
  
              this._changeTimer.cancel();
              this._changeTime=0;
              this._changeReason="";
              this._changeTimer=null;
              this._updateTimer.cancel();
              this._updateTimer=null;
              
              this._timerListener.tabpreview=null;
              this._timerListener=null;
              
              dump("Tabpreview destroyed\n");
            }
            catch (e)
            {
              dump(e+"\n");
            }
          }
        </body>
      </method>
      
      <method name="init">
        <body>
          if (!this._eventListener)
          {
            var self = this;
            this._eventListener = function(event) { self._eventFilter(event); };
          }
          if (this.previews.displayHeight>0)
            this.previews._resizePreview(this);
        </body>
      </method>
      
      <!-- Quick access to anonymous nodes -->
      
      <field name="_anonymousNodes">this.ownerDocument.getAnonymousNodes(this)[0].childNodes;</field>
      
      <field name="_topbox">
        this._anonymousNodes[0];
      </field>
      
      <field name="_bottombox">
        this._anonymousNodes[2];
      </field>
      
      <field name="uriField">
        this._bottombox.firstChild;
      </field>
      
      <field name="titleField">
        this._topbox.childNodes[2];
      </field>
      
      <field name="faviconIcon">
        this._topbox.firstChild;
      </field>
      
      <field name="_stack">
        this._anonymousNodes[1]
      </field>
      
      <field name="reloadButton">
        this._stack.lastChild.lastChild.lastChild;
      </field>
      
      <field name="stopButton">
        this._stack.lastChild.lastChild.firstChild;
      </field>
      
      <field name="backButton">
        this.stopButton.nextSibling.nextSibling;
      </field>
      
      <field name="forwardButton">
        this.backButton.nextSibling.nextSibling;
      </field>
      
      <field name="securityIcon">
        this._stack.lastChild.firstChild.lastChild;
      </field>
      
      <field name="canvas">
        this._stack.firstChild.firstChild;
      </field>
      
      <!-- Event handling gubbins -->
      
      <field name="_eventListener"/>
      
      <method name="_addListeners">
        <body>
          //this._logMessage("Add browser listeners");
          
          this._browser.addEventListener("DOMTitleChanged",      this._eventListener, false);
          this._browser.addEventListener("resize",               this._eventListener, false);
          this._browser.addEventListener("scroll",               this._eventListener, true);
          this._browser.addEventListener("load",                 this._eventListener, true);
          this._browser.addEventListener("unload",               this._eventListener, true);
          this._browser.addEventListener("pageshow",             this._eventListener, true);
          this._browser.addEventListener("pagehide",             this._eventListener, true);
          var WP = Components.interfaces.nsIWebProgress;
          var mask = WP.NOTIFY_ALL;
          if (this._browser.docShell)
          {
            this._browser.webProgress.addProgressListener(this._progressListener,mask);
            //this._browser.sessionHistory.addSHistoryListener(this._historyListener);
          }
          else
          {
            this._logError("Could not register browser progress listener");
          }
          WP=null;
          mask=null;
        </body>
      </method>
      
      <method name="_removeListeners">
        <body>
          try
          {
            //this._logMessage("Remove browser listeners");
          
            this._browser.removeEventListener("DOMTitleChanged", this._eventListener, false);
            this._browser.removeEventListener("resize",          this._eventListener, false);
            this._browser.removeEventListener("scroll",          this._eventListener, true);
            this._browser.removeEventListener("load",            this._eventListener, true);
            this._browser.removeEventListener("unload",          this._eventListener, true);
            this._browser.removeEventListener("pageshow",        this._eventListener, true);
            this._browser.removeEventListener("pagehide",        this._eventListener, true);
            if (this._browser.docShell)
            {
              this._browser.webProgress.removeProgressListener(this._progressListener);
              //this._browser.sessionHistory.removeSHistoryListener(this._historyListener);
            }
            else
            {
              this._logWarning("Could not unregister browser progress listener");
            }
          }
          catch (e)
          {
            dump(e+"\n");
          }
        </body>
      </method>
      
      <field name="_listenedDocuments">[]</field>
      
      <method name="_addDocumentListeners">
      	<parameter name="doc"/>
        <body>
        <![CDATA[
          var pos = this._listenedDocuments.indexOf(doc);
          if (pos<0)
          {
            this._logMessage("Adding document "+doc.location.href);
            
            doc.addEventListener("DOMNodeInserted",                this._eventListener, true);
            doc.addEventListener("DOMNodeRemoved",                 this._eventListener, true);
            doc.addEventListener("DOMNodeRemovedFromDocument",     this._eventListener, true);
            doc.addEventListener("DOMNodeInsertedIntoDocument",    this._eventListener, true);
            doc.addEventListener("DOMAttrModified",                this._eventListener, true);
            doc.addEventListener("DOMCharacterDataModified",       this._eventListener, true);
            doc.addEventListener("DOMElementNameChanged",          this._eventListener, true);
            doc.addEventListener("DOMAttributeNameChanged",        this._eventListener, true);
            doc.addEventListener("DOMActivate",                    this._eventListener, true);
            doc.addEventListener("DOMFocusIn",                     this._eventListener, true);
            doc.addEventListener("DOMFocusOut",                    this._eventListener, true);
            doc.addEventListener("DOMSubtreeModified",             this._eventListener, true);
            doc.addEventListener("scroll",                         this._eventListener, true);
            this._listenedDocuments.push(doc);
            
            this._logMessage("Listening to "+this._listenedDocuments.length+" documents");
          }
          else
          {
            //this._logMessage("Listeners already added\n");
          }
        ]]>
        </body>
      </method>
      
      <method name="_removeDocumentListeners">
        <parameter name="doc"/>
        <body>
        <![CDATA[
          var pos = this._listenedDocuments.indexOf(doc);
          if (pos>=0)
          {
            this._logMessage("Removing document "+doc.location.href);
            
            doc.removeEventListener("DOMNodeInserted",             this._eventListener, true);
            doc.removeEventListener("DOMNodeRemoved",              this._eventListener, true);
            doc.removeEventListener("DOMNodeRemovedFromDocument",  this._eventListener, true);
            doc.removeEventListener("DOMNodeInsertedIntoDocument", this._eventListener, true);
            doc.removeEventListener("DOMAttrModified",             this._eventListener, true);
            doc.removeEventListener("DOMCharacterDataModified",    this._eventListener, true);
            doc.removeEventListener("DOMElementNameChanged",       this._eventListener, true);
            doc.removeEventListener("DOMAttributeNameChanged",     this._eventListener, true);
            doc.removeEventListener("DOMActivate",                 this._eventListener, true);
            doc.removeEventListener("DOMFocusIn",                  this._eventListener, true);
            doc.removeEventListener("DOMFocusOut",                 this._eventListener, true);
            doc.removeEventListener("DOMSubtreeModified",          this._eventListener, true);
            doc.removeEventListener("scroll",                      this._eventListener, true);
            this._listenedDocuments.splice(pos,1);
            
            this._logMessage("Listening to "+this._listenedDocuments.length+" documents");
          }
          else
          {
            //this._logMessage("Listeners already removed\n");
          }
        ]]>
        </body>
      </method>
      
      <method name="_emptyDocumentListeners">
        <body>
        <![CDATA[
          while (this._listenedDocuments.length>0)
          {
            this._removeDocumentListeners(this._listenedDocuments[0]);
          }
        ]]>
        </body>
      </method>
      
      <method name="_findDocuments">
      	<parameter name="doc"/>
        <parameter name="newdocs"/>
      	<body>
      	<![CDATA[
      		if (doc)
      		{
            if (doc.contentDocument && (doc.contentDocument instanceof Document))
              doc=doc.contentDocument;

            if ((doc instanceof Document)&&(newdocs.indexOf(doc)==-1))
              newdocs.push(doc);

            if (doc.getElementsByTagName)
            {
  	      		var subdocs = doc.getElementsByTagName("frame");
  	      		for (var pos = 0; pos<subdocs.length; pos++)
  	      		{
                this._logMessage("Adding new frame");
        				this._findDocuments(subdocs[pos].contentDocument, newdocs);
  	      		}
  	      		subdocs = doc.getElementsByTagName("iframe");
  	      		for (var pos = 0; pos<subdocs.length; pos++)
  	      		{
                this._logMessage("Adding new iframe");
        				this._findDocuments(subdocs[pos].contentDocument, newdocs);
  	      		}
  	      		subdocs = doc.getElementsByTagName("browser");
  	      		for (var pos = 0; pos<subdocs.length; pos++)
  	      		{
                this._logMessage("Adding new browser");
        				this._findDocuments(subdocs[pos].contentDocument, newdocs);
  	      		}
            }
	      	}
          else
          {
            this._logWarning("Attempt to add null doc");
          }
				]]>
      	</body>
      </method>
      
      <method name="_checkDocuments">
        <parameter name="reason"/>
        <body>
        <![CDATA[
          if ((!this._browser)||(!this._browser.docShell))
            return;
            
          if (this._listenedDocuments.length>0)
          {
            if (this._listenedDocuments.indexOf(this._browser.contentDocument)>=0)
              return;
          }
          
          var newdocs = [];
          this._findDocuments(this._browser.contentDocument, newdocs);
          
          var target = newdocs.length;
          
          this._logMessage("checkDocuments");
          
          var lost = this._listenedDocuments.length;
          var pos=0;
          while (pos<this._listenedDocuments.length)
          {
            var fpos = newdocs.indexOf(this._listenedDocuments[pos]);
            if (fpos>=0)
            {
              this._logMessage("kept "+this._listenedDocuments[pos].location.href);
              newdocs.splice(fpos,1);
              pos++;
            }
            else
            {
              this._logMessage("lost "+this._listenedDocuments[pos].location.href);
              this._removeDocumentListeners(this._listenedDocuments[pos]);
            }
          }

          lost-=this._listenedDocuments.length;
          this._logWarning("Bad document tree detected from "+reason+": lost "+lost+" documents, gained "+newdocs.length+" documents, kept "+this._listenedDocuments.length+" documents.");

          for (var i=0; i<newdocs.length; i++)
          {
            this._addDocumentListeners(newdocs[i]);
            this._logMessage("gained "+this._listenedDocuments[pos].location.href);
          }
          
          if (this._listenedDocuments.length!=target)
          {
            this._logWarning("checkDocuments failure: "+target+" -> "+this._listenedDocuments.length);
          }
          
          this._documentLoaded();
        ]]>
        </body>
      </method>
      
      <method name="_startTimer">
        <parameter name="reason"/>
        <parameter name="selectedDelay"/>
        <parameter name="unselectedDelay"/>
        <body>
        <![CDATA[
          var delay = selectedDelay;
          
          if (!this.selected)
            delay = unselectedDelay;

          var date = Date.now()+delay;
          
          this._changeReason+=" "+reason;

          if (date>this._changeTime)
          {
            this._changeTimer.cancel();
            this._changeTimer.initWithCallback(this._timerListener, delay, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
            this._changeTime=date;
          }
        ]]>
        </body>
      </method>
      
      <method name="_documentLoaded">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer("load", this.previews.loadDelay, this.previews.unselectedLoadDelay);
        </body>
      </method>
      
      <method name="_documentTextInput">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer("text", this.previews.textDelay, this.previews.unselectedTextDelay);
        </body>
      </method>
      
      <method name="_documentChanged">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer("change", this.previews.changeDelay, this.previews.unselectedChangeDelay);
        </body>
      </method>
      
      <method name="_documentScrolled">
        <body>
          if (!this.previews)
            return;
            
          this._startTimer("scroll", this.previews.scrollDelay, this.previews.unselectedScrollDelay);
        </body>
      </method>
      
      <method name="_eventFilter">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if (!this.previews)
            return;
          
          try
          {
            //this._logMessage("Event - "+event.type);
            if (event.type=="DOMTitleChanged")
            {
              this.onTitleChange();
            }
            else if (event.type=="resize")
            {
              this._logMessage("Browser resized");
              this._updateSize(false);
            }
            else if ((event.type=="load")||(event.type=="pageshow"))
            {
              var doc = null;
              if (event.target)
              {
                if (event.target instanceof Document)
                {
                  doc=event.target;
                }
                else if (event.target.document)
                {
                  doc=event.target.document;
                }
                else if (event.target.contentDocument)
                {
                  doc=event.target.contentDocument;
                }
                else if (event.target.ownerDocument.documentElement==event.target)
                {
                  doc=event.target.ownerDocument;
                }
              }
              
              if (doc)
              {
                this._addDocumentListeners(doc);
                this._documentLoaded();
              }
              else
              {
                this._logWarning(event.type+" from unknown place: "+event.target);
              }
            }
            else if ((event.type=="unload")||(event.type=="pagehide"))
            {
              var doc = null;
              if (event.target)
              {
                if (event.target instanceof Document)
                {
                  doc=event.target;
                }
                else if (event.target.document)
                {
                  doc=event.target.document;
                }
                else if (event.target.contentDocument)
                {
                  doc=event.target.contentDocument;
                }
                else if (event.target.ownerDocument.documentElement==event.target)
                {
                  doc=event.target.ownerDocument;
                }
              }
              
              if (doc)
              {
                this._removeDocumentListeners(doc);
              }
              else
              {
                this._logWarning(event.type+" from unknown place: "+event.target);
              }
            }
            else if (this._listenedDocuments.indexOf(event.target.ownerDocument)>=0)
            {
              if (event.type=="scroll")
              {
                this._documentScrolled();
              }
              else if ((event.type.substring(0,3)=="DOM")&&(!this.loading))
              {
                if ((event.type=="DOMAttrModified")&&
                   ((event.attrName=="curpos")
                  ||(event.attrName=="maxpos")
                  ||(event.attrName=="pageincrement")))
                {
                    this._documentScrolled();
                    return;
                }
                if ((event.type=="DOMNodeInserted")||(event.type=="DOMNodeInsertedIntoDocument")||(event.type=="DOMCharacterDataModified"))
                {
                  if (event.target instanceof HTMLTextAreaElement)
                  {
                    this._documentTextInput();
                    return;
                  }
                  if (event.target instanceof HTMLInputElement)
                  {
                    if ((event.target.type=="text")||(event.target.type=="password"))
                    {
                      this._documentTextInput();
                      return;
                    }
                  }
                }
                this._documentChanged();
              }
            }
          }
          catch (e)
          {
            this._logWarning(e);
          }
        ]]>
        </body>
      </method>
      
      <field name="_historyListener">({
          tabpreview: this,

          OnHistoryGoBack : function(backURI)
          {
            return this.tabpreview.OnHistoryGoBack(backURI);
          },

          OnHistoryGoForward : function(forwardURI)
          {
            return this.tabpreview.OnHistoryGoForward(forwardURI);
          },
          
          OnHistoryGotoIndex : function(index, gotoURI)
          {
            return this.tabpreview.OnHistoryGotoIndex(index,gotoURI);
          },
          
          OnHistoryNewEntry : function(newURI)
          {
            this.tabpreview.OnHistoryNewEntry(newURI);
          },
          
          OnHistoryPurge : function(numEntries)
          {
            return this.tabpreview.OnHistoryPurge(numEntries);
          },
          
          OnHistoryReload : function(reloadURI, reloadFlags)
          {
            return this.tabpreview.OnHistoryReload(reloadURI, reloadFlags);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsISHistoryListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      
      <field name="_timerListener">({
          tabpreview: this,

          notify : function(timer)
          {
            if (this.tabpreview)
              this.tabpreview.notify(timer);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsITimerCallback) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      
      <field name="_progressListener">({
          tabpreview: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
            this.tabpreview.onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress);
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
            this.tabpreview.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
            this.tabpreview.onLocationChange(aWebProgress, aRequest, aLocation);
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
            this.tabpreview.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
            this.tabpreview.onSecurityChange(aWebProgress, aRequest, aState);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>

      <!-- Internal fields and methods -->
      
      <field name="_loadCount">0</field>
      <field name="_invalid">false</field>
      
      <method name="_logMessage">
        <parameter name="message"/>
        <body>
        <![CDATA[
          if (this.previews && this.previews._enableLogging)
          {
            Components.classes['@mozilla.org/consoleservice;1']
                      .getService(Components.interfaces.nsIConsoleService)
                      .logStringMessage("Tab Sidebar: "+message);
          }
        ]]>
        </body>
      </method>
      
      <method name="_logWarning">
        <parameter name="message"/>
        <body>
        <![CDATA[
          if (this.previews && this.previews._enableLogging)
          {
            var msg = Components.classes["@mozilla.org/scripterror;1"].createInstance(Components.interfaces.nsIScriptError);
            
            msg.init("Tab Sidebar: "+message,
                     "chrome://tabsidebar/content/widgets/tabpreview.xml",
                     "",
                     0,
                     0,
                     Components.interfaces.nsIScriptError.warningFlag,
                     "XUL JavaScript");
            
            var console = Components.classes["@mozilla.org/consoleservice;1"]
                                    .getService(Components.interfaces.nsIConsoleService);
            console.logMessage(msg);
          }
        ]]>
        </body>
      </method>
      
      <method name="_logError">
        <parameter name="message"/>
        <body>
        <![CDATA[
          if (this.previews && this.previews._enableLogging)
          {
            var msg = Components.classes["@mozilla.org/scripterror;1"].createInstance(Components.interfaces.nsIScriptError);
            
            msg.init("Tab Sidebar: "+message,
                     "chrome://tabsidebar/content/widgets/tabpreview.xml",
                     "",
                     0,
                     0,
                     Components.interfaces.nsIScriptError.errorFlag,
                     "XUL JavaScript");
            
            var console = Components.classes["@mozilla.org/consoleservice;1"]
                                    .getService(Components.interfaces.nsIConsoleService);
            console.logMessage(msg);
          }
        ]]>
        </body>
      </method>

      <field name="_browserWidth">-1</field>
      <field name="_browserHeight">-1</field>
      
      <method name="_updateSize">
        <parameter name="forceRedraw"/>
        <body>
        <![CDATA[
          var width = this._browser.parentNode.boxObject.width;
          var height = this._browser.parentNode.boxObject.height;
          
          var findbar = this._browser.ownerDocument.getElementById("FindToolbar");
          if (!findbar.hidden)
          {
            height+=findbar.boxObject.height;
          }
          
          this._logMessage("new size: "+width+"x"+height);
          var shouldRedraw = forceRedraw || this._browserWidth != width || this._browserHeight != height;
          
          this._browserWidth = width;
          this._browserHeight = height;
          this.previews.browserResized(this,this._browserWidth,this._browserHeight);
          if (shouldRedraw)
          {
            this.redraw();
            return true;
          }
          return false;
        ]]>
        </body>
      </method>
      
      <field name="_runningTimers">[]</field>
      
      <field name="_changeTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      <field name="_changeTime">0</field>
      <field name="_changeReason">0</field>
      
      <field name="_updateTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_browser"></field>
      <property name="browser">
        <getter>
          return this._browser;
        </getter>
        <setter>
        <![CDATA[
          if (this._browser)
          {
            this._removeListeners();
            this._emptyDocumentListeners();
          }
          this._browser=val;
          if (val)
          {
            var tab = this.tab;
            if (tab && tab.getAttribute("busy") == "true")
            {
              this._loadStarted();
            }
            else
            {
              this.loading=false;
            }

            if (this._browser.docShell)
            {
              if (this._browser.securityUI)
              {
                this._setSecurity(this._browser.securityUI.state);
              }
              var newdocs = [];
  						this._findDocuments(this._browser.contentDocument, newdocs);
              for (var i=0; i<newdocs.length; i++)
                this._addDocumentListeners(newdocs[i]);
            }
            this._addListeners();
            
            this._logMessage("Browser added");
            this._updateSize(true);
            this.update();
          }
        ]]>
        </setter>
      </property>

      <method name="_loadStarted">
        <body>
        <![CDATA[
          this._logMessage("loadStarted");
          
          this.loading=true;
          this._invalid=true;
          this.stopButton.disabled=false;

          //this._emptyDocumentListeners();
          this._changeTimer.cancel();
          this._changeTime=0;
          this._changeReason="";
          
          this._updateTimer.cancel();
          if ((this.previews)&&(this.previews.loadRefresh))
          {
            this._updateTimer.initWithCallback(this._timerListener, 
                                             this.previews.loadRefreshRate, 
                                             Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
          }
        ]]>
        </body>
      </method>
      
      <method name="_loadComplete">
        <body>
          this._logMessage("loadComplete");
          
          this.loading=false;
          this.stopButton.disabled=true;
          this._updateTimer.cancel();

          this._documentLoaded();
        </body>
      </method>
      
      <method name="_setSecurity">
        <parameter name="state"/>
        <body>
        <![CDATA[
          const WPL = Components.interfaces.nsIWebProgressListener;
                       
          switch (state)
          {
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_HIGH:
              this.setAttribute("security", "high");
              break;
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_LOW:
              this.setAttribute("security", "low");
              break;
            case WPL.STATE_IS_BROKEN:
              this.setAttribute("security", "broken");
              break;
            case WPL.STATE_IS_INSECURE:
            default:
              this.setAttribute("security", "none");
              break;
          }
          
          var icon = this.securityIcon;
          if ((this._browser.docShell)&&(this._browser.securityUI))
          {
            icon.setAttribute("tooltiptext",this._browser.securityUI.tooltipText);
          }
          else
          {
            icon.removeAttribute("tooltiptext");
          }
        ]]>
        </body>
      </method>
      
      <!-- Helper properties -->
      
      <property name="previews">
        <getter>
          return this.parentNode;
        </getter>
      </property>
      
      <property name="tab">
        <getter>
          return this.previews.getTabForPreview(this);
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      
      <property name="loading">
        <getter>
        <![CDATA[
          return this.hasAttribute("loading") && (this.getAttribute("loading")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("loading","false");
          }
          else
          {
            this.setAttribute("loading","true");
          }
          return val;
        ]]>
        </setter>
      </property>
      
      <property name="selected">
        <getter>
        <![CDATA[
          return this.hasAttribute("selected") && (this.getAttribute("selected")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("selected","false");
          }
          else
          {
            this.setAttribute("selected","true");
          }
          return val;
        ]]>
        </setter>
      </property>
      
      <!-- Configuration options -->
      <!-- Properties generated from the browser -->
      
      <property name="title">
        <getter>
          if ((!this._browser)||(!this._browser.docShell))
            return "";

          var title = this._browser.contentTitle;
          if (title &amp;&amp; title.length&gt;0)
          {
            return title;
          }
          else
          {
            return "&untitledTab;";
          }
        </getter>
      </property>

      <property name="uri">
        <getter>
          if ((!this._browser)||(!this._browser.docShell))
            return "";

          var uri = this._browser.currentURI;
          if (uri)
          {
            return uri.spec;
          }
          else
          {
            return "";
          }
        </getter>
      </property>

      <property name="icon">
        <getter>
        <![CDATA[
          if (!this._browser)
            return null;

          if ((Components.classes["@mozilla.org/browser/favicon-service;1"])&&(this._browser.docShell))
          {
            var favis = Components.classes["@mozilla.org/browser/favicon-service;1"]
                                  .getService(Components.interfaces.nsIFaviconService);
            return favis.getFaviconImageForPage(this._browser.currentURI).spec;
          }
          else
            return this._browser.mIconURL;
        ]]>
        </getter>
      </property>

      <!-- Methods -->
      
      <method name="checkMiddleClick">
        <parameter name="node"/>
        <parameter name="event"/>
        <body>
        <![CDATA[
          if (event.button == 1)
          {
            var func = new Function("event",node.getAttribute("oncommand"));
            func.call(node,event);
            if ("tagName" in node)
            {
              if (node.namespaceURI == "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
                  && (node.tagName == "menupopup" || node.tagName == "popup"))
                node.hidePopup();
            }
          }
        ]]>
        </body>
      </method>
      
      <method name="reload">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if ((!this._browser)||(!this._browser.docShell))
            return;

          if (event && event.shiftKey)
          {
            var reloadFlags = Components.interfaces.nsIWebNavigation.LOAD_FLAGS_BYPASS_PROXY | 
                              Components.interfaces.nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;
            this._browser.reloadWithFlags(reloadFlags);
          }
          else
          {
            this._browser.reload();
          }
        ]]>
        </body>
      </method>

      <method name="stop">
        <body>
        <![CDATA[
          if ((this._browser)&&(this._browser.docShell))
            this._browser.stop();
        ]]>
        </body>
      </method>

      <method name="gotoHistoryIndex">
        <parameter name="event"/>
        <body>
          var index = event.target.getAttribute("index");
          if (!index)
            return false;

          var where = whereToOpenLink(event);

          if (where == "current") {
            // Normal click.  Go there in the current tab and update session history.
            this._browser.gotoIndex(index);
            return true;
          }
          else {
            // Modified click.  Go there in a new tab/window.
            // This code doesn't copy history or work well with framed pages.

            var sessionHistory = this._browser.sessionHistory;
            var entry = sessionHistory.getEntryAtIndex(index, false);
            var url = entry.URI.spec;
            openUILinkIn(url, where);
            return true;
          }
        </body>
      </method>
      
      <method name="goBack">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if ((!this._browser)||(!this._browser.docShell))
            return;

          if (event)
          {
            var where = whereToOpenLink(event, false, false);
            if (where == "current")
            {
              this._browser.goBack();
            }
            else
            {
              var sessionHistory = this._browser.sessionHistory;
              var currentIndex = sessionHistory.index;
              var entry = sessionHistory.getEntryAtIndex(currentIndex - 1, false);
              var url = entry.URI.spec;
              openUILinkIn(url, where);
            }
          }
          else
          {
            this._browser.goBack();
          }
        ]]>
        </body>
      </method>
      
      <method name="populateBackMenu">
        <parameter name="event"/>
        <body>
        <![CDATA[
          var menu = event.target;
          
          while (menu.firstChild)
            menu.removeChild(menu.firstChild);

          if ((this._browser)&&(this._browser.docShell))
          {
            var sessionHistory = this._browser.sessionHistory;
  
            var index = sessionHistory.index;
            var entry;
  
            var end = (index > 8) ? index - 8 : 0;
            if ((index - 1) < end) return false;
            for (var pos = index - 1; pos >= end; pos--)
            {
              entry = sessionHistory.getEntryAtIndex(pos, false);
              if (entry)
              {
                var menuitem = document.createElement("menuitem");
                menuitem.setAttribute("label", entry.title);
                menuitem.setAttribute("index", pos);
                menu.appendChild(menuitem);
              }
            }
          }
          return true;
        ]]>
        </body>
      </method>

      <method name="goForward">
        <parameter name="event"/>
        <body>
        <![CDATA[
          if ((!this._browser)||(!this._browser.docShell))
            return;

          if (event)
          {
            var where = whereToOpenLink(event, false, false);
            if (where == "current")
            {
              this._browser.goForward();
            }
            else
            {
              var sessionHistory = this._browser.sessionHistory;
              var currentIndex = sessionHistory.index;
              var entry = sessionHistory.getEntryAtIndex(currentIndex + 1, false);
              var url = entry.URI.spec;
              openUILinkIn(url, where);
            }
          }
          else
          {
            this._browser.goForward();
          }
        ]]>
        </body>
      </method>

      <method name="populateForwardMenu">
        <parameter name="event"/>
        <body>
        <![CDATA[
          var menu = event.target;
          
          while (menu.firstChild)
            menu.removeChild(menu.firstChild);

          if ((this._browser)&&(this._browser.docShell))
          {
            var sessionHistory = this._browser.sessionHistory;
  
            var index = sessionHistory.index;
            var count = sessionHistory.count;
            var entry;
  
            var end  = ((count-index) > 8) ? index + 8 : count - 1;
            if ((index + 1) > end) return false;
            for (var pos = index + 1; pos <= end; pos++)
            {
              entry = sessionHistory.getEntryAtIndex(pos, false);
              if (entry)
              {
                var menuitem = document.createElement("menuitem");
                menuitem.setAttribute("label", entry.title);
                menuitem.setAttribute("index", pos);
                menu.appendChild(menuitem);
              }
            }
          }
          return true;
        ]]>
        </body>
      </method>

      <method name="viewSecurity">
        <body>
          var tabbrowser = this.previews.tabbrowser;
          if (tabbrowser.selectedTab!=this.tab)
          {
            tabbrowser.selectedTab=this.tab;
          }
          
          this.previews.window.setTimeout(this.previews.window.displaySecurityInfo,10);
        </body>
      </method>

      <method name="close">
        <body>
          var tabbrowser = this.previews.tabbrowser;
          if (this.previews.previews.length == 1)
          {
            if (this.uri != "about:blank")
              tabbrowser.loadURI("about:blank");

            if (this._browser.docShell)
              this._browser.sessionHistory.PurgeHistory(this._browser.sessionHistory.count);
          }
          else
          {
            if (!this.hasAttribute("browser"))
          	 this.setAttribute("browser", this._browser.parentNode.id);

            var tab = this.tab;
            this._destroy();
            tabbrowser.removeTab(tab);
          }
        </body>
      </method>

      <method name="update">
        <body>
          this.onLocationChange();

          this.onLinkIconAvailable();

          this.onTitleChange();
        </body>
      </method>
      
      <method name="historyChange">
        <body>
        <![CDATA[
          if ((this._browser)&&(this._browser.docShell))
          {
            var session = this._browser.sessionHistory;
            if (session)
            {
              this.backButton.disabled=(session.index<=0);
              this.forwardButton.disabled=((session.index+1)==session.count);
            }
          }
          else
          {
            this.backButton.disabled=true;
            this.forwardButton.disabled=true;
          }
        ]]>
        </body>
      </method>
      
      <method name="redraw">
        <body>
          if (!this.loading)
            this._redraw();
        </body>
      </method>
      
      <method name="_redraw">
        <body>
        <![CDATA[
          if (!this.previews)
            return;
          
          if (this.previews.displayHeight==0)
          {
            this._logWarning("Cancelling redraw");
            return;
          }
          var canvas = this.canvas;
          if (!canvas)
          {
            this._logError("Canvas doesnt exist.");
            return;
          }
          if (!canvas.hasAttribute("style"))
          {
            this._logWarning("Attempt to redraw before resize");
            return;
          }
          //this._logMessage("redraw");
          canvas.width = this.previews.contentWidth;
          canvas.height = this.previews.contentHeight;
          var ctx = null;
          try
          {
            ctx = canvas.getContext("2d");
          }
          catch (e)
          {
            return;
          }
          if ((this._browser)&&(this._browser.docShell))
          {
            var win = this._browser.contentWindow;
            var width = this._browserWidth;
            var scaling = this.previews.contentWidth/width;
            var height = Math.round(this.previews.contentHeight/scaling);
            ctx.save();
            ctx.scale(scaling,this.previews.contentHeight/height);
            try
            {
              var top = 0;
              var left = 0;
              if (this.previews.drawScrolled)
              {
                top=win.scrollY;
                left=win.scrollX;
              }
              else
              {
                height=Math.max(height,win.scrollY+1);
              }
              ctx.drawWindow(win,left,top,width,height,"rgba(255,255,255,255)");
            }
            catch (e)
            {
              dump(e+"\n");
              dump(win+" "+width+"x"+height+"\n");
            }
            ctx.restore();
          }
          else
          {
            ctx.clearRect(0, 0, this.previews.contentWidth, this.previews.contentHeight);
          }
        ]]>
        </body>
      </method>
      
      <!--  Start of nsISHistoryListener implementation -->
      <method name="OnHistoryGoBack">
        <parameter name="backURI"/>
        <body>
          this.historyChange();
          return true;
        </body>
      </method>
      
      <method name="OnHistoryGoForward">
        <parameter name="forwardURI"/>
        <body>
          this.historyChange();
          return true;
        </body>
      </method>
      
      <method name="OnHistoryGotoIndex">
        <parameter name="index"/>
        <parameter name="gotoURI"/>
        <body>
          this.historyChange();
          return true;
        </body>
      </method>
      
      <method name="OnHistoryNewEntry">
        <parameter name="newURI"/>
        <body>
          this.historyChange();
        </body>
      </method>
      
      <method name="OnHistoryPurge">
        <parameter name="numEntries"/>
        <body>
          this.historyChange();
          return true;
        </body>
      </method>
      
      <method name="OnHistoryReload">
        <parameter name="reloadURI"/>
        <parameter name="reloadFlags"/>
        <body>
          this.historyChange();
          return true;
        </body>
      </method>
      
      <!--  Start of nsIWebProgressListener implementation -->

      <method name="onLocationChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="location"/>
        <body>
          this._logMessage("onLocationChange");
          var uri = this.uri;

          var el = this.uriField;
          if (el)
            el.value=this.uri;

          var reload = this.reloadButton;
          reload.disabled=(uri=="about:blank" || uri=="");

          this.historyChange();
            
          if (!this.loading)
            this._checkDocuments("location");
        </body>
      </method>
      
      <method name="onStateChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="stateFlags"/>
        <parameter name="status"/>
        <body>
        <![CDATA[
          //this._logMessage("onStateChange "+stateFlags+" "+status);
          if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_IS_NETWORK)
          {
          	if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_STOP)
          	{
              if (this.loading)
                this._loadComplete();
              else
                this._logWarning("Received repeat load complete - "+stateFlags);
            }
            else if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_START)
            {
              if (!this.loading)
                this._loadStarted();
              else
                this._logWarning("Received repeat load start - "+stateFlags);
            }
      		}
      	]]>
        </body>
      </method>
      
      <method name="onStatusChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="status"/>
        <parameter name="message"/>
        <body>
          //this._logMessage("onStatusChange "+status);
        </body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="curSelfProgress"/>
        <parameter name="maxSelfProgress"/>
        <parameter name="curTotalProgress"/>
        <parameter name="maxTotalProgress"/>
        <body>
          //this._logMessage("onProgressChange ");
          this._invalid=true;
        </body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="state"/>
        <body>
          //this._logMessage("onSecurityChange "+state);
          this._setSecurity(state);
        </body>
      </method>
      
      <method name="onLinkIconAvailable">
        <body>
          this._logMessage("onLinkIconAvailable");
          var el = this.faviconIcon;
          if (el)
            el.src=this.icon;
            
          if (!this.loading)
            this._checkDocuments("icon");
        </body>
      </method>

      <method name="onTitleChange">
        <body>
          this._logMessage("onTitleChange");
          var el = this.titleField;
      
          if (el)
            el.value=this.title;
            
          if (!this.loading)
            this._checkDocuments("title");
        </body>
      </method>
            
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if ((!this.previews)||(!this._browser))
            return;
          
          if (timer==this._updateTimer)
          {
            //this.update();
            if (this._invalid)
            {
              this._redraw();
              this._invalid=false;
            }
            return;
          }
          
          this._logMessage("Timer fired - "+this._changeReason);
          
          this.redraw();

          if (this._changeReason.indexOf("load")>=0)
            this.update();
            
          this._changeReason="";
        ]]>
        </body>
      </method>
      
    </implementation>

    <handlers>
      <handler event="mousedown">
      <![CDATA[
        if (!this.previews)
          return;
          
        if (!this._browser)
          return;

        if (!this.previews)
          return;
          
        var tabbrowser = this.previews.tabbrowser;
        if (event.button==1)
        {
          tabbrowser.removeTab(this.tab);
        }
        else if (event.button==2)
        {
        }
        else
        {
          if (tabbrowser.selectedTab != this.tab)
          {
            var focus = false;
            if (document.commandDispatcher.focusedElement && document.commandDispatcher.focusedElement.parentNode==this.parentNode)
            {
              focus=true;
              this.tab.focus();
            }
            tabbrowser.selectedTab=this.tab;
            if (focus)
              this.focus();
          }
          else
          {
            this.focus();
          }
        }
      ]]>
      </handler>
    </handlers>
      
  </binding>

</bindings>
