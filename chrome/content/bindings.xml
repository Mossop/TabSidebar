<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd">

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox">

    <content>
      <xul:popupset>
        <xul:tooltip id="tabpreview_tooltip" orient="vertical">
          <xul:label value="Title"/>
          <xul:label value="URI"/>
        </xul:tooltip>
        <xul:popup id="tabpreview_context">
          <xul:menuitem id="selectTab" label="&tabsidebar.select.tooltip;"/>
          <xul:menuitem id="reloadTab" label="&tabsidebar.reload.tooltip;"/>
          <xul:menuitem id="closeTab" label="&tabsidebar.close.tooltip;"/>
          <xul:menuseparator/>
          <xul:menuitem id="refreshPreview" label="&tabsidebar.refresh.label;"/>
          <xul:menuseparator/>
          <xul:menuitem id="options" label="&tabsidebar.options.label;"/>
        </xul:popup>
        <xul:popup id="tabpreviews_context">
          <xul:menuitem id="refreshPreviews" label="&tabsidebar.refreshall.label;"/>
          <xul:menuseparator/>
          <xul:menuitem id="options" label="&tabsidebar.options.label;"/>
        </xul:popup>
      </xul:popupset>
      
      <xul:scrollbox context="tabpreviews_context" allowevents="true" anonid="scrollbox" align="stretch" orient="vertical"
                     ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode); event.stopPropagation();"
                     ondragover="nsDragAndDrop.dragOver(event, this.parentNode); event.stopPropagation();"
                     ondragdrop="nsDragAndDrop.drop(event, this.parentNode); event.stopPropagation();"
                     ondragexit="nsDragAndDrop.dragExit(event, this.parentNode); event.stopPropagation();">
        <children/>
      </xul:scrollbox>
    </content>
    
    <implementation implements="nsITimerCallback,nsIObserver">
    
      <constructor>
      <![CDATA[
        var scrollbox = document.getAnonymousElementByAttribute(this,"anonid","scrollbox");
        this.scrollBoxObject=scrollbox.boxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject);
        
        this.previewContainer=this;
        
        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranchInternal);
        prefs.addObserver("tabsidebar.", this, false);
        
        if (this.autoRefresh)
        {
          this._refreshTimer.initWithCallback(this, 
                                              this.refreshRate,
                                              Components.interfaces.nsITimer.TYPE_REPEATING_SLACK)
        }
        var menu = document.getAnonymousElementByAttribute(this,"id","refreshPreview");
        menu.disabled=!this.showPreview;
        menu = document.getAnonymousElementByAttribute(this,"id","refreshPreviews");
        menu.disabled=!this.showPreview;

      	var drop = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","box");
      	drop.className="dropindicator";
        this.previewContainer.appendChild(drop);
        
        var browsers = this.tabbrowser.browsers;
        for (var i=0; i<browsers.length; i++)
        {
          this.addPreview(browsers[i]);
        }
      	
      	var self=this;
      	this._eventListener = function(event) { self.eventFilter(event); };
      	
      	this.tabbrowser.tabContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.addEventListener("select", this._eventListener, false);
      	container.addEventListener("DOMNodeInserted", this._eventListener, false);
      	container.addEventListener("DOMNodeRemoved", this._eventListener, false);
      ]]>
      </constructor>
      
      <destructor>
      	this.tabbrowser.tabContainer.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.removeEventListener("select", this._eventListener, false);
      	container.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	container.removeEventListener("DOMNodeRemoved", this._eventListener, false);

        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranchInternal);
        prefs.removeObserver("tabsidebar.", this);
      </destructor>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener"/>

      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          if (event.type=="DOMNodeInserted")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.addPreview(browser);
        		}
        		else if (event.relatedNode==previews.tabbrowser.tabContainer)
        		{
        		  var browser = event.target.linkedBrowser;
        		  if (browser)
        		  {
        		    this.movePreview(browser);
        		  }
        		}
          }
          else if (event.type=="DOMNodeRemoved")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.removePreview(browser);
        		}
          }
          else if (event.type=="select")
          {
        		var newBrowser = this.tabbrowser.getBrowserAtIndex(this.tabbrowser.mTabContainer.selectedIndex);
        		this.selectPreview(newBrowser);
          }
        </body>
      </method>
      
      <!-- Internal fields and methods -->

      <field name="_selected"/>

      <field name="_refreshTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>

      <method name="_resize">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i]._resize();
        	}
        	this.redraw();
        ]]>
        </body>
      </method>

      <!-- Helper properties -->

      <field name="preferences">
        Components.classes["@mozilla.org/preferences-service;1"]
            .getService(Components.interfaces.nsIPrefService)
            .getBranch("tabsidebar.");</field>
      <field name="tabbrowser">window.parent.document.getElementById("content")</field>
      <field name="previewContainer"></field>
      <field name="scrollBoxObject"></field>
      
      <property name="previews">
        <getter>
          return document.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

      <property name="showButtonStrip">
        <getter>
          return this.preferences.getBoolPref("content.buttons");
        </getter>
      </property>
      
      <property name="showPreview">
        <getter>
        <![CDATA[
          return (this.previewWidth>0 && this.previewHeight>0 && this.preferences.getBoolPref("content.preview"));
        ]]>
        </getter>
      </property>
      
      <property name="showTitle">
        <getter>
          return this.preferences.getBoolPref("content.title");
        </getter>
      </property>
      
      <property name="showURI">
        <getter>
          return this.preferences.getBoolPref("content.uri");
        </getter>
      </property>
      
      <field name="_customSize">false</field>
      <property name="customSize">
        <getter>
          return this._customSize;
        </getter>
        <setter>
          if (this._customSize==val)
          {
            return val;
          }
          this._customSize=val;
          if (!val)
          {
            onResize();
          }
          redraw();
        </setter>
      </property>
      
      <field name="_width">0</field>
      <property name="previewWidth">
        <getter>
          return this._width;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._width && this._customSize)
          {
            return val;
          }
          this._width=val;
          this.customSize=true;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_height">0</field>
      <property name="previewHeight">
        <getter>
          return this._height;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._height && this._customSize)
          {
            return val;
          }
          this._height=val;
          this.customSize=true;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <property name="autoRefresh">
        <getter>
          return this.preferences.getBoolPref("autorefresh");
        </getter>
      </property>
      
      <property name="refreshRate">
        <getter>
          return Math.max(5,this.preferences.getIntPref("refreshrate"))*1000;
        </getter>
      </property>
      
      <property name="loadDelay">
        <getter>
          return this.preferences.getIntPref("loaddelay");
        </getter>
      </property>
      
      <property name="drawScrolled">
        <getter>
          return this.preferences.getBoolPref("drawscrolled");
        </getter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = document.getElementById(browser.parentNode.id);
        	if (preview)
        	{
        		return preview;
        	}
        	var id=browser.parentNode.id;
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		var preview = previews[i];
        		if (preview.browser==browser)
        		{
        		if (id)
        		{
        		  preview.id=id;
        		}
        		  return preview;
        		}
        	}
        ]]>
        </body>
      </method>
      
      <method name="getTabForPreview">
        <parameter name="preview"/>
        <body>
          var tabbrowser = this.tabbrowser;
          var panel = preview._browser.parentNode.id;
          return tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = document.createElement("tabpreview");
        	var drop = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","box");
        	drop.className="dropindicator";
        	var id=browser.parentNode.id;
        	if (id)
        	{
        		preview.id=id;
        	}
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
        	if (tab && tab.nextSibling)
        	{
        		var next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
        		if (next)
        		{
          		this.previewContainer.insertBefore(preview,next);
          		this.previewContainer.insertBefore(drop,next);
          	}
          	else
          	{
              this.previewContainer.appendChild(preview);
              this.previewContainer.appendChild(drop);
          	}
        	}
        	else
        	{
        		this.previewContainer.appendChild(preview);
        		this.previewContainer.appendChild(drop);
        	}
        	preview.init();
        	preview.browser=browser;
        	this.onResize();
        	
        	if (this.tabbrowser.selectedBrowser==browser)
        	{
        	  this.selectPreview(browser);
        	}
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
        	var preview = this.getPreviewForBrowser(browser);
        	preview.browser=null;
        	var drop = preview.nextSibling;
        	preview.parentNode.removeChild(preview);
        	drop.parentNode.removeChild(drop);
        	this.onResize();
        </body>
      </method>
      
      <method name="movePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          if (preview)
          {
            this.removePreview(browser);
            this.addPreview(browser);
          }
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.getPreviewForBrowser(browser);
        	if (this._selected)
        	{
            this._selected.setAttribute("selected","false");
        	}
        	if (preview)
        	{
          	preview.setAttribute("selected","true");
          }
        	this._selected=preview;
        	this.scrollBoxObject.ensureElementIsVisible(preview);
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="updateContent">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].updateContent();
        	}
        	this.onResize();
        ]]>
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].redraw();
        	}
        ]]>
        </body>
      </method>

      <method name="onResize">
        <body>
        <![CDATA[
          if (this.customSize)
          {
            return false;
          }
          var newWidth=0;
          var newHeight=0;
          var previews = this.previews;
          
          for (var i=0; i<previews.length; i++)
          {
            if (previews[i]._browser)
            {
              var preview = previews[i];
              var computed = window.getComputedStyle(preview,null);
              newWidth = parseInt(computed.width);
              if (newWidth<0)
              {
                newWidth=0;
              }
              var bwidth = preview._browser.contentWindow.innerWidth;
              var bheight = preview._browser.contentWindow.innerHeight;
              newHeight = parseInt((bheight/bwidth)*newWidth);

              break;
            }
          }
          
          if (this._width!=newWidth || this._height!=newHeight)
          {
            this._width=newWidth;
            this._height=newHeight;
          	this._resize();
          	return true;
          }
          return false;
        ]]>
        </body>
      </method>
      
      <!-- Start of DnD implementation -->

      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
        <![CDATA[
          if (aEvent.target.localName=="tabpreview")
          {
            aXferData.data = new TransferData();
            
            var URI = aEvent.target._browser.currentURI;
            if (URI)
            {
              aXferData.data.addDataForFlavour("text/unicode", URI.spec);
              aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + aEvent.target.contentTitle);
              aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + aEvent.target.contentTitle + '</a>');
            }
            else
            {
              aXferData.data.addDataForFlavour("text/unicode", "about:blank");
            }
          }
        ]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          if (aDragSession.canDrop && aDragSession.sourceNode &&
             (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
          {
            try
            {
              var newpos = this.getNewPosition(aEvent,aDragSession.sourceNode);
              var nextNode = this.previews[newpos];
              var drop = null;
              if (nextNode)
              {
                drop = nextNode.previousSibling;
              }
              else
              {
                drop = this.previews[this.previews.length-1].nextSibling;
              }
              if (!drop.hasAttribute("selected"))
              {
                this.onDragExit(aEvent,aDragSession);
                drop.setAttribute("selected","true");
              }
            }
            catch (e)
            {
              dump(e+"\n");
            }
          }
        ]]>
        </body>
      </method>

      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          if (aDragSession.sourceNode && 
             (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
          {
            var preview = null
            if (aDragSession.sourceNode.parentNode == this)
            {
              preview = aDragSession.sourceNode;              
            }
            else
            {
              preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
            }
            var newIndex = this.getNewPosition(aEvent, preview);
            var previews = this.previews;
            for (var i=0; i<previews.length; i++)
            {
              if (previews[i]==preview)
                break;
            }
            if (i<=newIndex)
            {
              newIndex--;
            }
            if (newIndex>=0)
            {
              this.tabbrowser.moveTabTo(preview.tab, newIndex);
            }
          }
          else
          {
            var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);

            // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
            // Also disallow dropping javascript: or data: urls--bail out
            if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
                /^\s*(javascript|data):/.test(url))
              return;

            this.tabbrowser.dragDropSecurityCheck(aEvent, aDragSession, url);

            var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                  .getService(Components.interfaces.nsIPrefService);
            var bgLoad = true;
            try
            {
              bgLoad = prefs.getBoolPref("browser.tabs.loadInBackground");
            }
            catch (e) { }

            if (aEvent.shiftKey)
              bgLoad = !bgLoad;

            if (aEvent.target.localName != "tabpreview")
            {
              // We're adding a new tab.
              this.tabbrowser.loadOneTab(url, null, null, null, bgLoad);
            }
            else
            {
              // Load in an existing tab.
              var preview = aEvent.target;
              preview.browser.loadURI(url);

              if (this.tabbrowser.selectedTab != preview.tab && !bgLoad)
                this.tabbrowser.selectedTab = preview.tab;
            }
          }
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          var drops = this.getElementsByTagName("box");
          for (var i = 0; i<drops.length; i++)
          {
            drops[i].removeAttribute("selected");
          }
        ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("text/x-moz-url");
          flavourSet.appendFlavour("text/unicode");
          flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
          return flavourSet;
        ]]>
        </body>
      </method>

      <method name="getNewPosition">
        <parameter name="aEvent"/>
        <parameter name="current"/>
        <body>
        <![CDATA[
          var diff = 0;
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
          {
            var bo = previews[i].boxObject;
            if ((bo.y+(bo.height/2))>aEvent.clientY)
            {
              return i-diff;
              break;
            }
          }
          return previews.length-diff;
        ]]>
        </body>
      </method>
      
      <!-- Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._refreshTimer)
          {
            this.redraw();
          }
        ]]>
        </body>
      </method>
      
      <!-- Start of nsIObserver implementation -->

      <method name="observe">
        <parameter name="subject"/>
        <parameter name="topic"/>
        <parameter name="data"/>
        <body>
        <![CDATA[
          data=data.substring(11);
          switch (data)
          {
            case "content.preview":
              var menu = document.getAnonymousElementByAttribute(this,"id","refreshPreview");
              menu.disabled=!this.showPreview;
              menu = document.getAnonymousElementByAttribute(this,"id","refreshPreviews");
              menu.disabled=!this.showPreview;
            case "content.buttons":
            case "content.title":
            case "content.uri":
              this.updateContent();
              break;
            case "refreshrate":
            case "autorefresh":
              this._refreshTimer.cancel();
              if (this.autoRefresh)
              {
                this._refreshTimer.initWithCallback(this, 
                                                    this.refreshRate,
                                                    Components.interfaces.nsITimer.TYPE_REPEATING_SLACK)
              }
              break;
            case "drawscrolled":
              this.redraw();
              break;
            case "previewWidth":
              if (this.preferences.prefHasUserValue(data))
              {
                this.previewWidth=this.preferences.getIntPref(data);
              }
              else
              {
                this.customSize=false;
              }
              break;
            case "previewHeight":
              if (this.preferences.prefHasUserValue(data))
              {
                this.previewHeight=this.preferences.getIntPref(data);
              }
              else
              {
                this.customSize=false;
              }
              break;
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      
      <handler event="command">
      <![CDATA[
        if (document.popupNode && document.popupNode.localName=="tabpreview")
        {
          if (event.originalTarget.id=="selectTab")
          {
            this.tabbrowser.selectedTab=document.popupNode.tab;
          }
          else if (event.originalTarget.id=="reloadTab")
          {
            this.tabbrowser.reloadTab(document.popupNode.tab);
          }
          else if (event.originalTarget.id=="refreshPreview")
          {
            document.popupNode.redraw();
          }
          else if (event.originalTarget.id=="closeTab")
          {
            this.tabbrowser.removeTab(document.popupNode.tab);
          }
        }
        if (event.originalTarget.id=="options")
        {
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefService);
          var instantApply = prefs.getBoolPref("browser.preferences.instantApply", false);
          var features = "chrome,titlebar,toolbar,centerscreen" + (instantApply ? ",dialog=no" : ",modal");
        
          var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                             .getService(Components.interfaces.nsIWindowMediator);
          var win = wm.getMostRecentWindow("Browser:Preferences");
          if (win)
          {
            win.focus();
          }
          else
          {
            window.openDialog("chrome://tabsidebar/content/preferences.xul",
                              "Preferences", features);
        	}
        }
        else if (event.originalTarget.id=="refreshPreviews")
        {
          this.redraw();
        }
      ]]>
      </handler>
      
      <handler event="dblclick">
      <![CDATA[
        if (event.originalTarget.parentNode.parentNode==this)
        {
          var newTab = this.tabbrowser.addTab("about:blank");
          this.tabbrowser.selectedTab=newTab;
        }
      ]]>
      </handler>
      
      <handler event="popupshowing">
        if (event.originalTarget.id=="tabpreview_tooltip")
        {
          var preview = document.tooltipNode;
          while (preview.localName!="tabpreview")
          {
            preview=preview.parentNode;
          }
          event.originalTarget.childNodes[0].value=preview.title;
          event.originalTarget.childNodes[1].value=preview.uri;
        }
      </handler>

    </handlers>

  </binding>
  
  <binding id="tabpreview" name="tabpreview">

    <content context="tabpreview_context" orient="vertical" align="stretch" selected="false" loading="false" security="none">
      <xul:stack>
        <xhtml:canvas anonid="canvas" tooltip="tabpreview_tooltip"/>
        <xul:vbox pack="start">
          <xul:hbox align="center" anonid="buttonstrip">
            <xul:toolbarbutton anonid="reload" tooltiptext="&tabsidebar.reload.tooltip;"/>
            <xul:image anonid="loading"/>
            <xul:toolbarbutton anonid="security"/>
            <xul:spacer flex="1"/>
            <xul:toolbarbutton anonid="close" tooltiptext="&tabsidebar.close.tooltip;"/>
          </xul:hbox>
        </xul:vbox>
      </xul:stack>
      <xul:vbox align="center" tooltip="tabpreview_tooltip">
        <xul:label anonid="title" crop="end"/>
        <xul:label anonid="uri" crop="end"/>
      </xul:vbox>
    </content>

    <implementation implements="nsIWebProgressListener,nsITimerCallback">

      <constructor>
      </constructor>

      <destructor>
        if (this._browser)
        {
          this._removeListeners();
        }
      </destructor>
      
      <method name="init">
        <body>
          this.updateContent();
          this._resize();
        </body>
      </method>
      
      <!-- Event handling gubbins -->
      
      <field name="_eventListener"/>
      
      <method name="_addListeners">
        <body>
          if (!this._eventListener)
          {
            var self = this;
            this._eventListener = function(event) { self.eventFilter(event); };
          }
          this._browser.addEventListener("DOMTitleChanged", this._eventListener,false);
          var WP = Components.interfaces.nsIWebProgress;
          var mask = WP.NOTIFY_STATE_DOCUMENT | WP.NOTIFY_STATUS | WP.NOTIFY_LOCATION | WP.NOTIFY_SECURITY;
          this._browser.webProgress.addProgressListener(this._progressListener,mask);
        </body>
      </method>
      
      <method name="_removeListeners">
        <body>
          this._browser.webProgress.removeProgressListener(this._progressListener);
          this._browser.removeEventListener("DOMTitleChanged",this._eventListener,false);
        </body>
      </method>
      
      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          var previews = document.getElementsByTagName("tabpreviews")[0];
          if (event.type=="DOMTitleChanged")
          {
            var preview = previews.getPreviewForBrowser(event.currentTarget);
            preview.update();
          }
        </body>
      </method>
      
      <field name="_progressListener">({
          tabpreview: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
            this.tabpreview.onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress);
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
            this.tabpreview.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
            this.tabpreview.onLocationChange(aWebProgress, aRequest, aLocation);
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
            this.tabpreview.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
            this.tabpreview.onSecurityChange(aWebProgress, aRequest, aState);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      <field name="_resizeListener"/>

      <!-- Internal fields and methods -->
      
      <field name="_redrawTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_loadTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_browser"></field>
      <property name="browser">
        <getter>
          return this._browser;
        </getter>
        <setter>
          if (this._browser)
          {
            this._removeListeners();
          }
          this._browser=val;
          if (val)
          {
            this._addListeners();
            if (this._browser.securityUI)
            {
              this._setSecurity(val.securityUI.state);
            }
          }
          this.update();
          this.redraw();
          return val;
        </setter>
      </property>

      <method name="_resize">
        <body>
        <![CDATA[
          var canvas = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          if (this.previews.showPreview)
          {
            canvas.style.display=null;
          }
          else
          {
            canvas.style.display="none";
          }
          canvas.setAttribute("width",this.previews.previewWidth);
          canvas.setAttribute("height",this.previews.previewHeight);
          canvas.style.width=this.previews.previewWidth+"px";
          canvas.style.height=this.previews.previewHeight+"px";
        ]]>
        </body>
      </method>
      
      <method name="_loadStarted">
        <body>
          this.loading=true;
          this._redrawTimer.cancel();
        </body>
      </method>
      
      <method name="_loadComplete">
        <body>
          this._loadTimer.cancel();
          var delay = this.previews.loadDelay;
          if (delay==0)
          {
            this.loading=false;
            this.update();
            this.redraw();
          }
          else
          {
            this._redrawTimer.initWithCallback(this, delay, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
          }
        </body>
      </method>
      
      <method name="_setSecurity">
        <parameter name="state"/>
        <body>
          const WPL = Components.interfaces.nsIWebProgressListener;
                       
          switch (state)
          {
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_HIGH:
              this.setAttribute("security", "high");
              break;
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_LOW:
              this.setAttribute("security", "low");
              break;
            case WPL.STATE_IS_BROKEN:
              this.setAttribute("security", "broken");
              break;
            case WPL.STATE_IS_INSECURE:
            default:
              this.setAttribute("security", "none");
              break;
          }
          
          var icon = document.getAnonymousElementByAttribute(this,"anonid","security");
          if (this._browser.securityUI)
          {
            icon.setAttribute("tooltiptext",this._browser.securityUI.tooltipText);
          }
          else
          {
            icon.removeAttribute("tooltiptext");
          }
        </body>
      </method>
      
      <!-- Helper properties -->
      
      <property name="previews">
        <getter>
          return this.parentNode;
        </getter>
      </property>
      
      <property name="tab">
        <getter>
          return this.previews.getTabForPreview(this);
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      
      <property name="loading">
        <getter>
        <![CDATA[
          return this.hasAttribute("loading") && (this.getAttribute("loading")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("loading","false");
          }
          else
          {
            this.setAttribute("loading","true");
          }
          return val;
        ]]>
        </setter>
      </property>
      
      <!-- Configuration options -->
      <!-- Properties generated from the browser -->
      
      <property name="title">
        <getter>
        <![CDATA[
          if (!this._browser)
          {
            return "";
          }
          var title = this._browser.contentTitle;
          if (title && title.length>0)
          {
            return title;
          }
          else
          {
            return "(Untitled)";
          }
        ]]>
        </getter>
      </property>

      <property name="uri">
        <getter>
          if (!this._browser)
          {
            return "";
          }
          var uri = this._browser.currentURI;
          if (uri)
          {
            return uri.spec;
          }
          else
          {
            return "";
          }
        </getter>
      </property>

      <!-- Methods -->
      
      <method name="update">
        <body>
          var el = document.getAnonymousElementByAttribute(this,"anonid","uri");
          if (el)
            el.value=this.uri;
          el = document.getAnonymousElementByAttribute(this,"anonid","title");
          if (el)
            el.value=this.title;
        </body>
      </method>
      
      <method name="updateContent">
        <body>
          var el = document.getAnonymousElementByAttribute(this,"anonid","buttonstrip");
          el.hidden=!this.previews.showButtonStrip;
          el = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          if (this.previews.showPreview)
          {
            if (el.style.display=="none")
            {
              el.style.display=null;
              this.redraw();
            }
            else
            {
              el.style.display=null;
            }
          }
          else
          {
            el.style.display="none";
          }
          el = document.getAnonymousElementByAttribute(this,"anonid","title");
          el.hidden=!this.previews.showTitle;
          el = document.getAnonymousElementByAttribute(this,"anonid","uri");
          el.hidden=!this.previews.showURI;
        </body>
      </method>
      
      <method name="redraw">
        <body>
          if (!this._browser || this._loading || !this.previews.showPreview)
          {
            return;
          }
          var canvas = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          var ctx = null;
          try
          {
            ctx = canvas.getContext("2d");
          }
          catch (e)
          {
            canvas.style.display="none";
            return;
          }
          var win = this._browser.contentWindow;
          ctx.clearRect(0, 0, this.previews.previewWidth, this.previews.previewHeight);
          ctx.save();
          ctx.scale(this.previews.previewWidth/win.innerWidth,this.previews.previewHeight/win.innerHeight);
          try
          {
            var top = 0;
            var left = 0;
            var height = win.innerHeight;
            var width = win.innerWidth;
            if (this.previews.drawScrolled)
            {
              top=win.scrollY;
              left=win.scrollX;
            }
            else
            {
              height=Math.max(height,win.scrollY+1);
            }
            ctx.drawWindow(win,left,top,width,height,"rgba(255,255,255,255)");
          }
          catch (e)
          {
            dump(e);
          }
          ctx.restore();
        </body>
      </method>
      
      <!--  Start of nsIWebProgressListener implementation -->

      <method name="onLocationChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="location"/>
        <body>
          this.update();
        </body>
      </method>
      
      <method name="onStateChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="stateFlags"/>
        <parameter name="status"/>
        <body>
        <![CDATA[
          if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_IS_DOCUMENT)
          {
          	if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_STOP)
          	{
              this._loadComplete();
            }
            else if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_START)
            {
              this._loadStarted();
            }
      		}
      	]]>
        </body>
      </method>
      
      <method name="onStatusChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="status"/>
        <parameter name="message"/>
        <body>
        </body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="curSelfProgress"/>
        <parameter name="maxSelfProgress"/>
        <parameter name="curTotalProgress"/>
        <parameter name="maxTotalProgress"/>
        <body>
        </body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="state"/>
        <body>
          this._setSecurity(state);
        </body>
      </method>
      
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._redrawTimer)
          {
            this.loading=false;
            this.update();
            this.redraw();
          }
        ]]>
        </body>
      </method>

    </implementation>

    <handlers>
      <handler event="click">
      <![CDATA[
        if (!this._browser)
        {
          return;
        }
        var tabbrowser = this.previews.tabbrowser;
        if (event.originalTarget.getAttribute("anonid")=="reload")
        {
          if (event.button==0)
            tabbrowser.reloadTab(this.tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="close")
        {
          if (event.button==0)
            tabbrowser.removeTab(this.tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="security")
        {
          if (tabbrowser.selectedTab!=this.tab)
          {
            tabbrowser.selectedTab=this.tab;
          }
          window.parent.displaySecurityInfo();
        }
        else
        {
          if (event.button==1)
          {
            tabbrowser.removeTab(this.tab);
          }
          else if (event.button==2)
          {
          }
          else
          {
            tabbrowser.selectedTab=this.tab;
          }
        }
      ]]>
      </handler>
    </handlers>
      
  </binding>
</bindings>
