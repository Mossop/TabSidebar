<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd">

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews">

    <content>
    </content>
    
    <implementation implements="nsITimerCallback">
    
      <constructor>
      <![CDATA[
        var browsers = this.tabbrowser.browsers;
        for (var i=0; i<browsers.length; i++)
        {
          this.addPreview(browsers[i]);
        }
        this.selectPreview(this.tabbrowser.selectedBrowser);
      	
      	var self=this;
      	this._eventListener = function(event) { self.eventFilter(event); };
      	
      	this.tabbrowser.tabContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.addEventListener("select", this._eventListener, false);
      	container.addEventListener("DOMNodeInserted", this._eventListener, false);
      	container.addEventListener("DOMNodeRemoved", this._eventListener, false);

        this._refreshTimer.initWithCallback(this, this.refreshRate, Components.interfaces.nsITimer. TYPE_REPEATING_SLACK);
      ]]>
      </constructor>
      
      <destructor>
      	this.tabbrowser.tabContainer.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.removeEventListener("select", this._eventListener, false);
      	container.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	container.removeEventListener("DOMNodeRemoved", this._eventListener, false);
      </destructor>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener"/>

      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          if (event.type=="DOMNodeInserted")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.addPreview(browser);
        		}
        		else if (event.relatedNode==previews.tabbrowser.tabContainer)
        		{
        		  var browser = event.target.linkedBrowser;
        		  if (browser)
        		  {
        		    this.movePreview(browser);
        		  }
        		}
          }
          else if (event.type=="DOMNodeRemoved")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.removePreview(browser);
        		}
          }
          else if (event.type=="select")
          {
        		var newBrowser = this.tabbrowser.getBrowserAtIndex(this.tabbrowser.mTabContainer.selectedIndex);
        		this.selectPreview(newBrowser);
          }
        </body>
      </method>
      
      <!-- Internal fields and methods -->

      <field name="_selected"/>

      <field name="_refreshTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>

      <!-- Helper properties -->

      <field name="tabbrowser">window.parent.document.getElementById("content")</field>
      
      <property name="previews">
        <getter>
          return document.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

      <field name="_refreshRate">60000</field>
      <property name="refreshRate">
        <getter>
          return this._refreshRate;
        </getter>
        <setter>
          this._refreshTimer.cancel();
          this._refreshRate=val;
          this._refreshTimer.initWithCallback(this, val, Components.interfaces.nsITimer. TYPE_REPEATING_SLACK);
        </setter>
      </property>
      
      <property name="drawScrolled">
        <getter>
          return true;
        </getter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = document.getElementById(browser.parentNode.id);
        	if (preview)
        	{
        		return preview;
        	}
        	var id=browser.parentNode.id;
        	var previews = document.getElementsByTagName("tabpreview");
        	for (var i=0; i<previews.length; i++)
        	{
        		var preview = previews[i];
        		if (preview.browser==browser)
        		{
        		if (id)
        		{
        		  preview.id=id;
        		}
        		  return preview;
        		}
        	}
        ]]>
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = document.createElement("tabpreview");
        	var id=browser.parentNode.id;
        	if (id)
        	{
        		preview.id=id;
        	}
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
        	if (tab && tab.nextSibling)
        	{
        		var next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
        		if (next)
        		{
          		this.insertBefore(preview,next);
          	}
          	else
          	{
              this.appendChild(preview);
          	}
        	}
        	else
        	{
        		this.appendChild(preview);
        	}
        	preview.browser=browser;
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
        	var preview = this.getPreviewForBrowser(browser);
        	preview.browser=null;
        	preview.parentNode.removeChild(preview);
        </body>
      </method>
      
      <method name="movePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          if (preview)
          {
            this.removeChild(preview);
            this.addPreview(browser);
          }
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.getPreviewForBrowser(browser);
        	if (this._selected)
        	{
            this._selected.selected=false;
        	}
        	if (preview)
        	{
          	preview.selected=true;
          }
        	this._selected=preview;
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].redraw();
        	}
        ]]>
        </body>
      </method>

      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._refreshTimer)
          {
            this.redraw();
          }
        ]]>
        </body>
      </method>

    </implementation>
    
  </binding>
  
  <binding id="tabpreview" name="tabpreview">

    <content orient="vertical" align="stretch" selected="false" loading="false" security="none">
      <xul:vbox anonid="box" align="stretch" tooltip="previewtooltip">
        <xul:hbox align="center">
          <xul:toolbarbutton anonid="reload" tooltiptext="&tabsidebar.reload.tooltip;"/>
          <xul:image anonid="loading"/>
          <xul:toolbarbutton anonid="security"/>
          <xul:spacer flex="1"/>
          <xul:toolbarbutton anonid="close" tooltiptext="&tabsidebar.close.tooltip;"/>
        </xul:hbox>
        <xhtml:canvas anonid="canvas"/>
        <xul:label anonid="title" crop="end"/>
        <xul:label anonid="uri" crop="end"/>
      </xul:vbox>
    </content>

    <implementation implements="nsIWebProgressListener,nsITimerCallback">

      <constructor>
      </constructor>

      <destructor>
        if (this._browser)
        {
          this._removeListeners();
        }
      </destructor>
      
      <!-- Event handling gubbins -->
      
      <field name="_eventListener"/>
      
      <method name="_addListeners">
        <body>
          if (!this._eventListener)
          {
            var self = this;
            this._eventListener = function(event) { self.eventFilter(event); };
          }
          this._browser.addEventListener("DOMTitleChanged", this._eventListener,false);
          var WP = Components.interfaces.nsIWebProgress;
          var mask = WP.NOTIFY_STATE_DOCUMENT | WP.NOTIFY_STATUS | WP.NOTIFY_LOCATION | WP.NOTIFY_SECURITY;
          this._browser.webProgress.addProgressListener(this._progressListener,mask);
        </body>
      </method>
      
      <method name="_removeListeners">
        <body>
          this._browser.webProgress.removeProgressListener(this._progressListener);
          this._browser.removeEventListener("DOMTitleChanged",this._eventListener,false);
        </body>
      </method>
      
      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          var previews = document.getElementsByTagName("tabpreviews")[0];
          if (event.type=="DOMTitleChanged")
          {
            var preview = previews.getPreviewForBrowser(event.currentTarget);
            preview.update();
          }
        </body>
      </method>
      
      <field name="_progressListener">({
          tabpreview: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
            this.tabpreview.onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress);
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
            this.tabpreview.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
            this.tabpreview.onLocationChange(aWebProgress, aRequest, aLocation);
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
            this.tabpreview.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
            this.tabpreview.onSecurityChange(aWebProgress, aRequest, aState);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      <field name="_resizeListener"/>

      <!-- Internal fields and methods -->
      
      <field name="_redrawTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_width"/>
      <property name="previewWidth">
        <getter>
          return this._width;
        </getter>
      </property>
      
      <field name="_height"/>
      <property name="previewHeight">
        <getter>
          return this._height;
        </getter>
      </property>

      <field name="_browser"></field>
      <property name="browser">
        <getter>
          return this._browser;
        </getter>
        <setter>
          if (this._browser)
          {
            this._removeListeners();
          }
          this._browser=val;
          if (val)
          {
            this._addListeners();
            if (this._browser.securityUI)
            {
              this._setSecurity(val.securityUI.state);
            }
          }
          this.update();
          this.redraw();
        </setter>
      </property>

      <method name="_resize">
        <body>
        <![CDATA[
          var canvas = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          if (this._browser)
          {
            var computed = window.getComputedStyle(canvas.parentNode,null);
            this._width = parseInt(computed.width);
            if (this._width<0)
            {
              this._width=0;
            }
            var bwidth = this._browser.contentWindow.innerWidth;
            var bheight = this._browser.contentWindow.innerHeight;
            this._height = parseInt((bheight/bwidth)*this._width);
          }
          else
          {
            this._width=0;
            this._height=0;
          }
          canvas.style.width=this._width+"px";
          canvas.style.height=this._height+"px";
          canvas.setAttribute("width",this._width);
          canvas.setAttribute("height",this._height);
        ]]>
        </body>
      </method>
      
      <method name="_loadStarted">
        <body>
          this.loading=true;
          this._redrawTimer.cancel();
        </body>
      </method>
      
      <method name="_loadComplete">
        <body>
          this._redrawTimer.initWithCallback(this, 500, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
        </body>
      </method>
      
      <method name="_setSecurity">
        <parameter name="state"/>
        <body>
          const WPL = Components.interfaces.nsIWebProgressListener;
                       
          switch (state)
          {
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_HIGH:
              this.setAttribute("security", "high");
              break;
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_LOW:
              this.setAttribute("security", "low");
              break;
            case WPL.STATE_IS_BROKEN:
              this.setAttribute("security", "broken");
              break;
            case WPL.STATE_IS_INSECURE:
            default:
              this.setAttribute("security", "none");
              break;
          }
          
          var icon = document.getAnonymousElementByAttribute(this,"anonid","security");
          if (this._browser.securityUI)
          {
            icon.setAttribute("tooltiptext",this._browser.securityUI.tooltipText);
          }
          else
          {
            icon.removeAttribute("tooltiptext");
          }
        </body>
      </method>
      
      <!-- Helper properties -->
      
      <property name="previews">
        <getter>
          return this.parentNode;
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      
      <property name="loading">
        <getter>
        <![CDATA[
          return this.hasAttribute("loading") && (this.getAttribute("loading")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("loading","false");
          }
          else
          {
            this.setAttribute("loading","true");
          }
        ]]>
        </setter>
      </property>
      
      <property name="selected">
        <getter>
        <![CDATA[
          return this.hasAttribute("selected") && (this.getAttribute("selected")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("selected","false");
          }
          else
          {
            this.setAttribute("selected","true");
          }
        ]]>
        </setter>
      </property>

      <!-- Configuration options -->

      <property name="refreshRate">
        <getter>
          return this.previews.refreshRate;
        </getter>
      </property>
      
      <property name="drawScrolled">
        <getter>
          return this.previews.drawScrolled;
        </getter>
      </property>
      
      <!-- Properties generated from the browser -->
      
      <property name="title">
        <getter>
        <![CDATA[
          if (!this._browser)
          {
            return "";
          }
          var title = this._browser.contentTitle;
          if (title && title.length>0)
          {
            return title;
          }
          else
          {
            return "(Untitled)";
          }
        ]]>
        </getter>
      </property>

      <property name="uri">
        <getter>
          if (!this._browser)
          {
            return "";
          }
          var uri = this._browser.currentURI;
          if (uri)
          {
            return uri.spec;
          }
          else
          {
            return "";
          }
        </getter>
      </property>

      <!-- Methods -->
      
      <method name="update">
        <body>
          var el = document.getAnonymousElementByAttribute(this,"anonid","uri");
          if (el)
            el.value=this.uri;
          el = document.getAnonymousElementByAttribute(this,"anonid","title");
          if (el)
            el.value=this.title;
        </body>
      </method>
      
      <method name="redraw">
        <body>
          this._resize();
          if (!this._browser || this._loading)
          {
            return;
          }
          var canvas = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          var ctx = canvas.getContext("2d");
          var win = this._browser.contentWindow;
          ctx.clearRect(0, 0, this._width, this._height);
          ctx.save();
          ctx.scale(this._width/win.innerWidth,this._height/win.innerHeight);
          try
          {
            var top = 0;
            var left = 0;
            var height = win.innerHeight;
            var width = win.innerWidth;
            if (this.drawScrolled)
            {
              top=win.scrollY;
              left=win.scrollX;
            }
            else
            {
              height=Math.max(height,win.scrollY+1);
            }
            ctx.drawWindow(win,left,top,width,height,"rgba(255,255,255,255)");
          }
          catch (e)
          {
            dump(e);
          }
          ctx.restore();
        </body>
      </method>
      
      <!--  Start of nsIWebProgressListener implementation -->

      <method name="onLocationChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="location"/>
        <body>
          this.update();
        </body>
      </method>
      
      <method name="onStateChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="stateFlags"/>
        <parameter name="status"/>
        <body>
        <![CDATA[
          if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_IS_DOCUMENT)
          {
          	if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_STOP)
          	{
              this._loadComplete();
            }
            else if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_START)
            {
              this._loadStarted();
            }
      		}
      	]]>
        </body>
      </method>
      
      <method name="onStatusChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="status"/>
        <parameter name="message"/>
        <body>
        </body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="curSelfProgress"/>
        <parameter name="maxSelfProgress"/>
        <parameter name="curTotalProgress"/>
        <parameter name="maxTotalProgress"/>
        <body>
        </body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="state"/>
        <body>
          this._setSecurity(state);
        </body>
      </method>
      
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._redrawTimer)
          {
            this.loading=false;
            this.update();
            this.redraw();
          }
        ]]>
        </body>
      </method>

    </implementation>

    <handlers>
      <handler event="click">
        if (!this._browser)
        {
          return;
        }
        var tabbrowser = this.previews.tabbrowser;
        var panel = this._browser.parentNode.id;
        var tab = tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        if (event.originalTarget.getAttribute("anonid")=="reload")
        {
          tabbrowser.reloadTab(tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="close")
        {
          tabbrowser.removeTab(tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="security")
        {
        }
        else
        {
          if (event.button==1)
          {
            tabbrowser.removeTab(tab);
          }
          else if (event.button==2)
          {
          }
          else
          {
            tabbrowser.selectedTab=tab;
          }
        }
      </handler>
    </handlers>
      
  </binding>
</bindings>
