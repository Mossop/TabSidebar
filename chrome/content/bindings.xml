<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd">

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox">

    <content>
      <xul:tooltip id="tabpreview_tooltip" orient="vertical">
        <xul:label value="Title"/>
        <xul:label value="URI"/>
      </xul:tooltip>

      <xul:scrollbox allowevents="true" anonid="scrollbox" align="stretch" orient="vertical">
        <children/>
      </xul:scrollbox>
    </content>
    
    <implementation implements="nsITimerCallback,nsIObserver">
    
      <constructor>
      <![CDATA[
        var scrollbox = document.getAnonymousElementByAttribute(this,"anonid","scrollbox");
        this.scrollBoxObject=scrollbox.boxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject);
        
        this.previewContainer=this;
        
        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranchInternal);
        prefs.addObserver("tabsidebar.", this, false);
        this.observe(prefs,"","tabsidebar.drawscrolled");
        this.observe(prefs,"","tabsidebar.refreshrate");
        this.observe(prefs,"","tabsidebar.autorefresh");

        var browsers = this.tabbrowser.browsers;
        for (var i=0; i<browsers.length; i++)
        {
          this.addPreview(browsers[i]);
        }
      	
      	var self=this;
      	this._eventListener = function(event) { self.eventFilter(event); };
      	
      	this.tabbrowser.tabContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.addEventListener("select", this._eventListener, false);
      	container.addEventListener("DOMNodeInserted", this._eventListener, false);
      	container.addEventListener("DOMNodeRemoved", this._eventListener, false);
      ]]>
      </constructor>
      
      <destructor>
      	this.tabbrowser.tabContainer.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.removeEventListener("select", this._eventListener, false);
      	container.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	container.removeEventListener("DOMNodeRemoved", this._eventListener, false);

        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranchInternal);
        prefs.removeObserver("tabsidebar.", this);
      </destructor>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener"/>

      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          if (event.type=="DOMNodeInserted")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.addPreview(browser);
        		}
        		else if (event.relatedNode==previews.tabbrowser.tabContainer)
        		{
        		  var browser = event.target.linkedBrowser;
        		  if (browser)
        		  {
        		    this.movePreview(browser);
        		  }
        		}
          }
          else if (event.type=="DOMNodeRemoved")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.removePreview(browser);
        		}
          }
          else if (event.type=="select")
          {
        		var newBrowser = this.tabbrowser.getBrowserAtIndex(this.tabbrowser.mTabContainer.selectedIndex);
        		this.selectPreview(newBrowser);
          }
        </body>
      </method>
      
      <!-- Internal fields and methods -->

      <field name="_selected"/>

      <field name="_refreshTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>

      <method name="_resize">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i]._resize();
        	}
        	this.redraw();
        ]]>
        </body>
      </method>

      <!-- Helper properties -->

      <field name="preferences">
        Components.classes["@mozilla.org/preferences-service;1"]
            .getService(Components.interfaces.nsIPrefService)
            .getBranch("tabsidebar.");</field>
      <field name="tabbrowser">window.parent.document.getElementById("content")</field>
      <field name="previewContainer"></field>
      <field name="scrollBoxObject"></field>
      
      <property name="previews">
        <getter>
          return document.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

      <property name="showButtonStrip">
        <getter>
          return this.preferences.getBoolPref("content.buttons");
        </getter>
      </property>
      
      <property name="showPreview">
        <getter>
        <![CDATA[
          return (this.previewWidth!=0 && this.previewHeight!=0 && this.preferences.getBoolPref("content.preview"));
        ]]>
        </getter>
      </property>
      
      <property name="showTitle">
        <getter>
          return this.preferences.getBoolPref("content.title");
        </getter>
      </property>
      
      <property name="showURI">
        <getter>
          return this.preferences.getBoolPref("content.uri");
        </getter>
      </property>
      
      <field name="_customSize">false</field>
      <property name="customSize">
        <getter>
          return this._customSize;
        </getter>
        <setter>
          if (this._customSize==val)
          {
            return val;
          }
          this._customSize=val;
          if (!val)
          {
            onResize();
          }
          redraw();
        </setter>
      </property>
      
      <field name="_width">0</field>
      <property name="previewWidth">
        <getter>
          return this._width;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._width && this._customSize)
          {
            return val;
          }
          this._width=val;
          this.customSize=true;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_height">0</field>
      <property name="previewHeight">
        <getter>
          return this._height;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._height && this._customSize)
          {
            return val;
          }
          this._height=val;
          this.customSize=true;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_autoRefresh">false</field>
      <property name="autoRefresh">
        <getter>
          return this._autoRefresh;
        </getter>
        <setter>
          if (val==this._autoRefresh)
          {
            return val;
          }
          this._autoRefresh=val;
          if (val)
          {
            this._refreshTimer.cancel();
          }
          else
          {
            this._refreshTimer.initWithCallback(this, this.refreshRate, Components.interfaces.nsITimer. TYPE_REPEATING_SLACK);
          }
          return val;
        </setter>
      </property>
      
      <field name="_refreshRate">120</field>
      <property name="refreshRate">
        <getter>
          return this._refreshRate*1000;
        </getter>
        <setter>
          if (this._refreshRate==val)
          {
            return val;
          }
          this._refreshRate=val;
          if (this.autoRefresh)
          {
            this._refreshTimer.cancel();
            this._refreshTimer.initWithCallback(this, val, Components.interfaces.nsITimer. TYPE_REPEATING_SLACK);
          }
          return val;
        </setter>
      </property>
      
      <field name="_loadDelay">500</field>
      <property name="loadDelay">
        <getter>
          return this._loadDelay;
        </getter>
        <setter>
          if (this._loadDelay==val)
          {
            return val;
          }
          this._loadDelay=val;
          return val;
        </setter>
      </property>
      
      <field name="_drawScrolled">true</field>
      <property name="drawScrolled">
        <getter>
          return this._drawScrolled;
        </getter>
        <setter>
          if (val==this._drawScrolled)
          {
            return val;
          }
          this._drawScrolled=val;
          this.redraw();
          return val;
        </setter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = document.getElementById(browser.parentNode.id);
        	if (preview)
        	{
        		return preview;
        	}
        	var id=browser.parentNode.id;
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		var preview = previews[i];
        		if (preview.browser==browser)
        		{
        		if (id)
        		{
        		  preview.id=id;
        		}
        		  return preview;
        		}
        	}
        ]]>
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = document.createElement("tabpreview");
        	var id=browser.parentNode.id;
        	if (id)
        	{
        		preview.id=id;
        	}
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
        	if (tab && tab.nextSibling)
        	{
        		var next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
        		if (next)
        		{
          		this.previewContainer.insertBefore(preview,next);
          	}
          	else
          	{
              this.previewContainer.appendChild(preview);
          	}
        	}
        	else
        	{
        		this.previewContainer.appendChild(preview);
        	}
        	preview.init();
        	preview.browser=browser;
        	this.onResize();
        	
        	if (this.tabbrowser.selectedBrowser==browser)
        	{
        	  this.selectPreview(browser);
        	}
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
        	var preview = this.getPreviewForBrowser(browser);
        	preview.browser=null;
        	preview.parentNode.removeChild(preview);
        	this.onResize();
        </body>
      </method>
      
      <method name="movePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          if (preview)
          {
            preview.parentNode.removeChild(preview);
            this.addPreview(browser);
          }
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.getPreviewForBrowser(browser);
        	if (this._selected)
        	{
            this._selected.setAttribute("selected","false");
        	}
        	if (preview)
        	{
          	preview.setAttribute("selected","true");
          }
        	this._selected=preview;
        	this.scrollBoxObject.ensureElementIsVisible(preview);
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="updateContent">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].updateContent();
        	}
        	this.onResize();
        ]]>
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].redraw();
        	}
        ]]>
        </body>
      </method>

      <method name="onResize">
        <body>
        <![CDATA[
          if (this.customSize)
          {
            return false;
          }
          var newWidth=0;
          var newHeight=0;
          var previews = this.previews;
          
          for (var i=0; i<previews.length; i++)
          {
            if (previews[i]._browser)
            {
              var preview = previews[i];
              var computed = window.getComputedStyle(preview,null);
              newWidth = parseInt(computed.width);
              if (newWidth<0)
              {
                newWidth=0;
              }
              var bwidth = preview._browser.contentWindow.innerWidth;
              var bheight = preview._browser.contentWindow.innerHeight;
              newHeight = parseInt((bheight/bwidth)*newWidth);

              break;
            }
          }
          
          if (this._width!=newWidth || this._height!=newHeight)
          {
            this._width=newWidth;
            this._height=newHeight;
          	this._resize();
          	return true;
          }
          return false;
        ]]>
        </body>
      </method>
      
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._refreshTimer)
          {
            this.redraw();
          }
        ]]>
        </body>
      </method>
      
      <!-- Start of nsIObserver implementation -->

      <method name="observe">
        <parameter name="subject"/>
        <parameter name="topic"/>
        <parameter name="data"/>
        <body>
        <![CDATA[
          data=data.substring(11);
          if (data.substring(0,8)=="content.")
          {
            this.updateContent();
            return;
          }
          switch (data)
          {
            case "refreshrate":
              this.refreshRate=this.preferences.getIntPref(data);
              break;
            case "autorefresh":
              this.autoRefresh=this.preferences.getBoolPref(data);
              break;
            case "drawscrolled":
              this.drawScrolled=this.preferences.getBoolPref(data);
              break;
            case "loaddelay":
              this.loadDelay=this.preferences.getIntPref(data);
              break;
            case "previewWidth":
              if (this.preferences.prefHasUserValue(data))
              {
                this.previewWidth=this.preferences.getIntPref(data);
              }
              else
              {
                this.customSize=false;
              }
              break;
            case "previewHeight":
              if (this.preferences.prefHasUserValue(data))
              {
                this.previewHeight=this.preferences.getIntPref(data);
              }
              else
              {
                this.customSize=false;
              }
              break;
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      
      <handler event="dblclick">
      <![CDATA[
        if (event.originalTarget==this && event.button==0)
        {
          var newTab = this.tabbrowser.addTab("about:blank");
          this.tabbrowser.selectedTab=newTab;
        }
      ]]>
      </handler>
      
      <handler event="popupshowing">
        dump("showing\n");
        dump(document.popupNode+"\n");
        dump(event.target.localName+"\n");
        dump(event.currentTarget.localName+"\n");
        dump(event.originalTarget.localName+"\n");
      </handler>

    </handlers>

  </binding>
  
  <binding id="tabpreview" name="tabpreview">

    <content orient="vertical" align="stretch" selected="false" loading="false" security="none">
      <xul:hbox align="center" anonid="buttonstrip">
        <xul:toolbarbutton anonid="reload" tooltiptext="&tabsidebar.reload.tooltip;"/>
        <xul:image anonid="loading"/>
        <xul:toolbarbutton anonid="security"/>
        <xul:spacer flex="1"/>
        <xul:toolbarbutton anonid="close" tooltiptext="&tabsidebar.close.tooltip;"/>
      </xul:hbox>
      <xul:vbox align="center" tooltip="tabpreview_tooltip">
        <xhtml:canvas anonid="canvas" tooltip="tabpreview_tooltip"/>
        <xul:label anonid="title" crop="end"/>
        <xul:label anonid="uri" crop="end"/>
      </xul:vbox>
    </content>

    <implementation implements="nsIWebProgressListener,nsITimerCallback">

      <constructor>
      </constructor>

      <destructor>
        if (this._browser)
        {
          this._removeListeners();
        }
      </destructor>
      
      <method name="init">
        <body>
          this.updateContent();
          this._resize();
        </body>
      </method>
      
      <!-- Event handling gubbins -->
      
      <field name="_eventListener"/>
      
      <method name="_addListeners">
        <body>
          if (!this._eventListener)
          {
            var self = this;
            this._eventListener = function(event) { self.eventFilter(event); };
          }
          this._browser.addEventListener("DOMTitleChanged", this._eventListener,false);
          var WP = Components.interfaces.nsIWebProgress;
          var mask = WP.NOTIFY_STATE_DOCUMENT | WP.NOTIFY_STATUS | WP.NOTIFY_LOCATION | WP.NOTIFY_SECURITY;
          this._browser.webProgress.addProgressListener(this._progressListener,mask);
        </body>
      </method>
      
      <method name="_removeListeners">
        <body>
          this._browser.webProgress.removeProgressListener(this._progressListener);
          this._browser.removeEventListener("DOMTitleChanged",this._eventListener,false);
        </body>
      </method>
      
      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          var previews = document.getElementsByTagName("tabpreviews")[0];
          if (event.type=="DOMTitleChanged")
          {
            var preview = previews.getPreviewForBrowser(event.currentTarget);
            preview.update();
          }
        </body>
      </method>
      
      <field name="_progressListener">({
          tabpreview: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
            this.tabpreview.onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress);
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
            this.tabpreview.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
            this.tabpreview.onLocationChange(aWebProgress, aRequest, aLocation);
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
            this.tabpreview.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
            this.tabpreview.onSecurityChange(aWebProgress, aRequest, aState);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      <field name="_resizeListener"/>

      <!-- Internal fields and methods -->
      
      <field name="_redrawTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_browser"></field>
      <property name="browser">
        <getter>
          return this._browser;
        </getter>
        <setter>
          if (this._browser)
          {
            this._removeListeners();
          }
          this._browser=val;
          if (val)
          {
            this._addListeners();
            if (this._browser.securityUI)
            {
              this._setSecurity(val.securityUI.state);
            }
          }
          this.update();
          this.redraw();
          return val;
        </setter>
      </property>

      <method name="_resize">
        <body>
        <![CDATA[
          var canvas = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          if (this.previews.showPreview)
          {
            canvas.style.display=null;
          }
          else
          {
            canvas.style.display="none";
          }
          canvas.setAttribute("width",this.previews.previewWidth);
          canvas.setAttribute("height",this.previews.previewHeight);
          canvas.style.width=this.previews.previewWidth+"px";
          canvas.style.height=this.previews.previewHeight+"px";
        ]]>
        </body>
      </method>
      
      <method name="_loadStarted">
        <body>
          this.loading=true;
          this._redrawTimer.cancel();
        </body>
      </method>
      
      <method name="_loadComplete">
        <body>
          this._redrawTimer.initWithCallback(this, this.previews.loadDelay, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
        </body>
      </method>
      
      <method name="_setSecurity">
        <parameter name="state"/>
        <body>
          const WPL = Components.interfaces.nsIWebProgressListener;
                       
          switch (state)
          {
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_HIGH:
              this.setAttribute("security", "high");
              break;
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_LOW:
              this.setAttribute("security", "low");
              break;
            case WPL.STATE_IS_BROKEN:
              this.setAttribute("security", "broken");
              break;
            case WPL.STATE_IS_INSECURE:
            default:
              this.setAttribute("security", "none");
              break;
          }
          
          var icon = document.getAnonymousElementByAttribute(this,"anonid","security");
          if (this._browser.securityUI)
          {
            icon.setAttribute("tooltiptext",this._browser.securityUI.tooltipText);
          }
          else
          {
            icon.removeAttribute("tooltiptext");
          }
        </body>
      </method>
      
      <!-- Helper properties -->
      
      <property name="previews">
        <getter>
          return this.parentNode;
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      
      <property name="loading">
        <getter>
        <![CDATA[
          return this.hasAttribute("loading") && (this.getAttribute("loading")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("loading","false");
          }
          else
          {
            this.setAttribute("loading","true");
          }
          return val;
        ]]>
        </setter>
      </property>
      
      <!-- Configuration options -->
      <!-- Properties generated from the browser -->
      
      <property name="title">
        <getter>
        <![CDATA[
          if (!this._browser)
          {
            return "";
          }
          var title = this._browser.contentTitle;
          if (title && title.length>0)
          {
            return title;
          }
          else
          {
            return "(Untitled)";
          }
        ]]>
        </getter>
      </property>

      <property name="uri">
        <getter>
          if (!this._browser)
          {
            return "";
          }
          var uri = this._browser.currentURI;
          if (uri)
          {
            return uri.spec;
          }
          else
          {
            return "";
          }
        </getter>
      </property>

      <!-- Methods -->
      
      <method name="update">
        <body>
          var el = document.getAnonymousElementByAttribute(this,"anonid","uri");
          if (el)
            el.value=this.uri;
          el = document.getAnonymousElementByAttribute(this,"anonid","title");
          if (el)
            el.value=this.title;
        </body>
      </method>
      
      <method name="updateContent">
        <body>
          var el = document.getAnonymousElementByAttribute(this,"anonid","buttonstrip");
          el.hidden=!this.previews.showButtonStrip;
          el = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          if (this.previews.showPreview)
          {
            if (el.style.display=="none")
            {
              el.style.display=null;
              this.redraw();
            }
            else
            {
              el.style.display=null;
            }
          }
          else
          {
            el.style.display="none";
          }
          el = document.getAnonymousElementByAttribute(this,"anonid","title");
          el.hidden=!this.previews.showTitle;
          el = document.getAnonymousElementByAttribute(this,"anonid","uri");
          el.hidden=!this.previews.showURI;
        </body>
      </method>
      
      <method name="redraw">
        <body>
          if (!this._browser || this._loading || !this.previews.showPreview)
          {
            return;
          }
          var canvas = document.getAnonymousElementByAttribute(this,"anonid","canvas");
          var ctx = null;
          try
          {
            ctx = canvas.getContext("2d");
          }
          catch (e)
          {
            canvas.style.display="none";
            return;
          }
          var win = this._browser.contentWindow;
          ctx.clearRect(0, 0, this.previews.previewWidth, this.previews.previewHeight);
          ctx.save();
          ctx.scale(this.previews.previewWidth/win.innerWidth,this.previews.previewHeight/win.innerHeight);
          try
          {
            var top = 0;
            var left = 0;
            var height = win.innerHeight;
            var width = win.innerWidth;
            if (this.previews.drawScrolled)
            {
              top=win.scrollY;
              left=win.scrollX;
            }
            else
            {
              height=Math.max(height,win.scrollY+1);
            }
            ctx.drawWindow(win,left,top,width,height,"rgba(255,255,255,255)");
          }
          catch (e)
          {
            dump(e);
          }
          ctx.restore();
        </body>
      </method>
      
      <!--  Start of nsIWebProgressListener implementation -->

      <method name="onLocationChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="location"/>
        <body>
          this.update();
        </body>
      </method>
      
      <method name="onStateChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="stateFlags"/>
        <parameter name="status"/>
        <body>
        <![CDATA[
          if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_IS_DOCUMENT)
          {
          	if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_STOP)
          	{
              this._loadComplete();
            }
            else if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_START)
            {
              this._loadStarted();
            }
      		}
      	]]>
        </body>
      </method>
      
      <method name="onStatusChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="status"/>
        <parameter name="message"/>
        <body>
        </body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="curSelfProgress"/>
        <parameter name="maxSelfProgress"/>
        <parameter name="curTotalProgress"/>
        <parameter name="maxTotalProgress"/>
        <body>
        </body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="state"/>
        <body>
          this._setSecurity(state);
        </body>
      </method>
      
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._redrawTimer)
          {
            this.loading=false;
            this.update();
            this.redraw();
          }
        ]]>
        </body>
      </method>

    </implementation>

    <handlers>
      <handler event="click">
        if (!this._browser)
        {
          return;
        }
        var tabbrowser = this.previews.tabbrowser;
        var panel = this._browser.parentNode.id;
        var tab = tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        if (event.originalTarget.getAttribute("anonid")=="reload")
        {
          tabbrowser.reloadTab(tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="close")
        {
          tabbrowser.removeTab(tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="security")
        {
          var args = {doc: this._browser.contentDocument, initialTab: "securityTab"};
          var url = this._browser.contentDocument.location;

          var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService();
          var windowManagerInterface = windowManager.QueryInterface(Components.interfaces.nsIWindowMediator);
          var windows = windowManagerInterface.getEnumerator("Browser:page-info");

          // Check for windows matching the url
          while (windows.hasMoreElements()) {
            var currentWindow = windows.getNext();
            if (currentWindow.document.firstChild.getAttribute("relatedUrl") == url) {
              currentWindow.focus();
              return;
            }
          }

          window.openDialog("chrome://browser/content/pageInfo.xul", "_blank", "chrome,dialog=no", args);
        }
        else
        {
          if (event.button==1)
          {
            tabbrowser.removeTab(tab);
          }
          else if (event.button==2)
          {
          }
          else
          {
            tabbrowser.selectedTab=tab;
          }
        }
      </handler>
    </handlers>
      
  </binding>
</bindings>
