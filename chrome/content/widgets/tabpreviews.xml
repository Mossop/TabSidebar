<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings [
<!ENTITY % bidiDTD SYSTEM "chrome://global/locale/global.dtd">
<!ENTITY % tabbrowserDTD SYSTEM "chrome://global/locale/tabbrowser.dtd" >
<!ENTITY % tabSidebarDTD SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd" >
%bidiDTD;
%tabbrowserDTD;
%tabSidebarDTD;
]>

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/widgets/tabpreviews.css"/>
    </resources>
    
    <content class="tbs-tabpreviews" hide="" style="visibility: hidden" orient="horizontal" align="stretch" flex="1">
      <xul:popupset>
      
        <xul:tooltip id="tabpreview_tooltip" orient="vertical">
          <xul:label class="tbs-tooltip-title" value="Title"/>
          <xul:label class="tbs-tooltip-uri" value="URI"/>
        </xul:tooltip>
        
      </xul:popupset>
      
      <xul:vbox class="tbs-drop-indicator-bar">
        <xul:hbox chromedir="&locale.dir;" class="tbs-drop-indicator"/>
      </xul:vbox>          

      <xul:box class="tbs-focusdetector" style="-moz-user-focus: normal"/>
      
      <xul:scrollbox class="tbs-scrollbox" allowevents="true" anonid="scrollbox"
                     ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode); event.stopPropagation();"
                     ondragover="nsDragAndDrop.dragOver(event, this.parentNode); event.stopPropagation();"
                     ondragdrop="nsDragAndDrop.drop(event, this.parentNode); event.stopPropagation();"
                     ondragexit="nsDragAndDrop.dragExit(event, this.parentNode); event.stopPropagation();"
                     align="stretch" orient="vertical" flex="1">
        

        <children/>

      </xul:scrollbox>
    </content>
    
    <implementation implements="nsITimerCallback,nsIObserver">
    
      <constructor>
      <![CDATA[
        var topwin = window;
        while (topwin.parent && topwin.parent != topwin)
        {
          topwin=topwin.parent;
        }
        this.window = topwin;
        this.tabbrowser = topwin.document.getElementById("content");
        this.tabbrowser.addProgressListener(this._progressListener);
        
        this._loadLocale();
        this._initTree();
        this._migrateOldSettings();
        this._initSettings();

        this._logMessage("Tab Sidebar Startup");
        
        this._initEvents();
      ]]>
      </constructor>
      
      <method name="_load">
        <body>
        <![CDATA[
          this._logMessage("Tab Sidebar Load");
          
          var selectedpos = -1;
          var browsers = this.tabbrowser.browsers;
          for (var i=0; i<browsers.length; i++)
          {
            if (this.tabbrowser.selectedBrowser==browsers[i])
            {
              selectedpos=i;
              break;
            }
          }
          for (var i=selectedpos; i>=0; i--)
          {
            this.addPreview(browsers[i]);
          }
          for (var i=selectedpos+1; i<browsers.length; i++)
          {
            this.addPreview(browsers[i]);
          }
        ]]>
        </body>
      </method>
      
      <method name="_loadLocale">
        <body>
          var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"]
                              .getService(Components.interfaces.nsIStringBundleService);
          var bundle = sbs.createBundle("chrome://browser/locale/browser.properties");
        </body>
      </method>
      
      <method name="_initTree">
        <body>
        	var drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
        	drop.className="dropindicator groove";
        	drop.setAttribute("orient","horizontal");
          this.previewContainer.appendChild(drop);
        </body>
      </method>

      <method name="_migrateOldSettings">
        <body>
        <![CDATA[
          var oprefs = Components.classes["@mozilla.org/preferences-service;1"]
                                 .getService(Components.interfaces.nsIPrefService)
                                 .getBranch("tabsidebar.").QueryInterface(Components.interfaces.nsIPrefBranch);
          var list = oprefs.getChildList("",{});
          for (var i=0; i<list.length; i++)
          {
            if (oprefs.prefHasUserValue(list[i]))
            {
              var type = oprefs.getPrefType(list[i]);
              switch (type)
              {
                case Components.interfaces.nsIPrefBranch.PREF_STRING:
                  this.preferences.setStringPref(list[i],oprefs.getStringPref(list[i]));
                  break;
                case Components.interfaces.nsIPrefBranch.PREF_INT:
                  this.preferences.setIntPref(list[i],oprefs.getIntPref(list[i]));
                  break;
                case Components.interfaces.nsIPrefBranch.PREF_BOOL:
                  this.preferences.setBoolPref(list[i],oprefs.getBoolPref(list[i]));
                  break;
              }
              oprefs.clearUserPref(list[i]);
            }
          }
        ]]>
        </body>
      </method>

      <method name="_initSettings">
        <body>
          try
          {
            this._enableLogging = this.preferences.getBoolPref("enablelogging");
          }
          catch (e)
          {
          }

          this._showReload = this.preferences.getBoolPref("content.reload");
          this._showStop = this.preferences.getBoolPref("content.stop");
          this._showForward = this.preferences.getBoolPref("content.forward");
          this._showBack = this.preferences.getBoolPref("content.back");
          this._showURI = this.preferences.getBoolPref("content.uri");

          this._drawScrolled = true; //this.preferences.getBoolPref("drawscrolled");
          this._loadRefresh = this.preferences.getBoolPref("loadrefresh");
          this._loadRefreshRate = this.preferences.getIntPref("loadrefreshrate");
          this._loadDelay = this.preferences.getIntPref("loaddelay");
          this._unselectedLoadDelay = this.preferences.getIntPref("unselectedloaddelay");
          this._textDelay = this.preferences.getIntPref("textdelay");
          this._unselectedTextDelay = this.preferences.getIntPref("unselectedtextdelay");
          this._changeDelay = this.preferences.getIntPref("changedelay");
          this._unselectedChangeDelay = this.preferences.getIntPref("unselectedchangedelay");
          this._scrollDelay = this.preferences.getIntPref("scrolldelay");
          this._unselectedScrollDelay = this.preferences.getIntPref("unselectedscrolldelay");
          
          this.updateContent();        
        </body>
      </method>
      
      <method name="_initEvents">
        <body>
          this.preferences.addObserver("", this, false);
          
        	var self=this;
        	this._eventListener = function(event) { self._eventFilter(event); };
        	
        	this.tabbrowser.tabContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
        	this.tabbrowser.mPanelContainer.addEventListener("select", this._eventListener, false);
        	this.tabbrowser.mPanelContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
        	this.tabbrowser.mPanelContainer.addEventListener("DOMNodeRemoved", this._eventListener, false);
        	
        	window.addEventListener("load", function(event) { self._load(); }, false);
        	window.addEventListener("unload", function(event) { self._destroy(); }, false);
        </body>
      </method>
      
      <destructor>
        this._logMessage("tabpreviews destructor");
        this._destroy();
      </destructor>
      
      <field name="_destroyed" value="false"/>
      <method name="_destroy">
        <body>
          if (!this._destroyed)
          {
            this.tabbrowser.removeProgressListener(this._progressListener);

            while (this.firstChild)
            {
              if (this.firstChild.localName == "tabpreview")
              {
                this.firstChild._destroy();
              }
              this.removeChild(this.firstChild);
            }
    
          	this.tabbrowser.tabContainer.removeEventListener("DOMNodeInserted", this._eventListener, false);
          	var container = this.tabbrowser.mPanelContainer;
          	container.removeEventListener("select", this._eventListener, false);
          	container.removeEventListener("DOMNodeInserted", this._eventListener, false);
          	container.removeEventListener("DOMNodeRemoved", this._eventListener, false);
    
            this.preferences.removeObserver("", this);
            this.preferences=null;
            
            this.tabbrowser=null;
            this.window=null;
  
            this._resizeTimer.cancel();
            this._resizeTimer=null;

            this._destroyed=true;
          }
        </body>
      </method>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener"/>

      <method name="_eventFilter">
        <parameter name="event"/>
        <body>
          if (event.type=="DOMNodeInserted")
          {
        		if (event.relatedNode==this.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.addPreview(browser);
        		}
        		else if (event.relatedNode==this.tabbrowser.tabContainer)
        		{
        		  var browser = event.target.linkedBrowser;
        		  if (browser)
        		  {
        		    this.addPreview(browser);
        		  }
        		}
          }
          else if (event.type=="DOMNodeRemoved")
          {
        		if (event.relatedNode==this.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.removePreview(browser);
        		}
          }
          else if (event.type=="select")
          {
        		var newBrowser = this.tabbrowser.getBrowserAtIndex(this.tabbrowser.mTabContainer.selectedIndex);
        		this.selectPreview(newBrowser);
          }
        </body>
      </method>
      
      <field name="_progressListener">({
          tabpreviews: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
          },

          onLinkIconAvailable : function(browser)
          {
            var preview = this.tabpreviews.getPreviewForBrowser(browser);
            if (preview)
              preview.onLinkIconAvailable();
          },
          
          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>

      <!-- Internal fields and methods -->

      <field name="_selected"/>
      <field name="_redrawPreview">0</field>
      
      <field name="_resizeTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>

      <method name="_resize">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	if (previews.length>0)
            this._logMessage("Resizing to "+this.displayWidth+"x"+this.displayHeight);
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i]._resize();
        	}
        ]]>
        </body>
      </method>
      
      <method name="_logMessage">
        <parameter name="message"/>
        <body>
          if (this._enableLogging)
          {
            Components.classes['@mozilla.org/consoleservice;1']
                      .getService(Components.interfaces.nsIConsoleService)
                      .logStringMessage("Tab Sidebar: "+message);
          }
        </body>
      </method>
      
      <method name="_logWarning">
        <parameter name="message"/>
        <body>
          if (this._enableLogging)
          {
            var msg = Components.classes["@mozilla.org/scripterror;1"].createInstance(Components.interfaces.nsIScriptError);
            
            msg.init("Tab Sidebar: "+message,
                     "chrome://tabsidebar/content/widgets/tabpreviews.xml",
                     "",
                     0,
                     0,
                     Components.interfaces.nsIScriptError.warningFlag,
                     "XUL JavaScript");
            
            var console = Components.classes["@mozilla.org/consoleservice;1"]
                                    .getService(Components.interfaces.nsIConsoleService);
            console.logMessage(msg);
          }
        </body>
      </method>
      
      <method name="_logError">
        <parameter name="message"/>
        <body>
          if (this._enableLogging)
          {
            var msg = Components.classes["@mozilla.org/scripterror;1"].createInstance(Components.interfaces.nsIScriptError);
            
            msg.init("Tab Sidebar: "+message,
                     "chrome://tabsidebar/content/widgets/tabpreviews.xml",
                     "",
                     0,
                     0,
                     Components.interfaces.nsIScriptError.errorFlag,
                     "XUL JavaScript");
            
            var console = Components.classes["@mozilla.org/consoleservice;1"]
                                    .getService(Components.interfaces.nsIConsoleService);
            console.logMessage(msg);
          }
        </body>
      </method>

      <!-- Helper properties -->

      <field name="preferences">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefService)
                  .getBranch("extensions.tabsidebar.").QueryInterface(Components.interfaces.nsIPrefBranchInternal);
      </field>
      <field name="tabbrowser"/>
      <field name="window"/>
      <field name="previewContainer">this</field>
      <field name="focusDetector">this.ownerDocument.getAnonymousNodes(this)[2]</field>
      <field name="scrollBox">this.ownerDocument.getAnonymousNodes(this)[3]</field>
      <field name="scrollBoxObject">this.scrollBox.boxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject)</field>
      <field name="dragDropBar">this.ownerDocument.getAnonymousNodes(this)[1]</field>
      <field name="dragDropIndicator">this.dragDropBar.firstChild;</field>
      
      <property name="previews">
        <getter>
          return this.ownerDocument.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

      <field name="_enableLogging">false</field>
      <property name="enableLogging" onget="return this._enableLogging;"/>
      
      <field name="_showReload">true</field>
      <property name="showReload" onget="return this._showReload;"/>
            
      <field name="_showStop">true</field>
      <property name="showStop" onget="return this._showStop;"/>
            
      <field name="_showForward">true</field>
      <property name="showForward" onget="return this._showForward;"/>
            
      <field name="_showBack">true</field>
      <property name="showBack" onget="return this._showBack;"/>
            
      <field name="_showURI">false</field>
      <property name="showURI" onget="return this._showURI;"/>
      
      <field name="_displayWidth">-1</field>
      <property name="displayWidth" onget="return this._displayWidth;"/>
      
      <field name="_displayHeight">-1</field>
      <property name="displayHeight" onget="return this._displayHeight;"/>
      
      <field name="_contentWidth">-1</field>
      <property name="contentWidth" onget="return this._contentWidth;"/>
      
      <field name="_contentHeight">-1</field>
      <property name="contentHeight" onget="return this._contentHeight;"/>
      
      <field name="_suppressSizing">false</field>
      <property name="suppressSizing">
        <getter>
          return this._suppressSizing;
        </getter>
        <setter>
          if (this._suppressSizing != val)
          {
            this._suppressSizing = val;
            this.browserResized(this._selected._browser.contentWindow.innerWidth,this._selected._browser.contentWindow.innerHeight);
          }
          return val;
        </setter>
      </property>

      <field name="_loadRefresh"/>
      <property name="loadRefresh" onget="return this._loadRefresh;"/>
      
      <field name="_loadRefreshRate"/>
      <property name="loadRefreshRate">
        <getter>
          return Math.max(100,this._loadRefreshRate);
        </getter>
      </property>
      
      <field name="_loadDelay"/>
      <property name="loadDelay" onget="return this._loadDelay;"/>
      
      <field name="_unselectedLoadDelay"/>
      <property name="unselectedLoadDelay" onget="return this._unselectedLoadDelay;"/>
      
      <field name="_changeDelay"/>
      <property name="changeDelay" onget="return this._changeDelay;"/>
      
      <field name="_unselectedChangeDelay"/>
      <property name="unselectedChangeDelay" onget="return this._unselectedChangeDelay;"/>
      
      <field name="_textDelay"/>
      <property name="textDelay" onget="return this._textDelay;"/>
      
      <field name="_unselectedTextDelay"/>
      <property name="unselectedTextDelay" onget="return this._unselectedTextDelay;"/>
      
      <field name="_scrollDelay"/>
      <property name="scrollDelay" onget="return this._scrollDelay;"/>
      
      <field name="_unselectedScrollDelay"/>
      <property name="unselectedScrollDelay" onget="return this._unselectedScrollDelay;"/>
      
      <field name="_drawScrolled"/>
      <property name="drawScrolled">
        <getter>
          //return this._drawScrolled;
          return true; /* bug 36 */
        </getter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = this.ownerDocument.getElementById(browser.parentNode.id);
        	if (preview)
        	{
        		return preview;
        	}
        	var id=browser.parentNode.id;
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		var preview = previews[i];
        		if (preview.browser==browser)
        		{
          		if (id)
          		{
          		  preview.id=id;
          		}
        		  return preview;
        		}
        	}
        	return null;
        ]]>
        </body>
      </method>
      
      <method name="getTabForPreview">
        <parameter name="preview"/>
        <body>
          var tabbrowser = this.tabbrowser;
          var panel = preview._browser.parentNode.id;
          return tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = this.getPreviewForBrowser(browser);
          var drop = null;
          if (preview)
          {
            preview._destroy();
            var drop = preview.nextSibling;
          }
          else
          {
          	preview = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","tabpreview");
          	drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
          	drop.className="dropindicator groove";
          	drop.setAttribute("orient","horizontal");
          }
        	var id=browser.parentNode.id;
        	if (id)
        	{
        		preview.id=id;
        	}
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
          var next = null;
        	if (tab && tab.nextSibling)
        	{
        		next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
        	}
      		this.previewContainer.insertBefore(preview,next);
      		this.previewContainer.insertBefore(drop,next);

        	preview.init();

        	if (this.tabbrowser.selectedBrowser==browser)
        	{
        	  this.selectPreview(browser);
        	}
        	else if (tab && tab.hasAttribute("selected"))
        	{
            preview.selected=(tab.getAttribute("selected")=="true");
        	}
        	
        	preview.browser=browser;
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
        	var preview = this.getPreviewForBrowser(browser);
        	if (preview)
        	{
          	var drop = preview.nextSibling;
          	preview._destroy();
          	preview.parentNode.removeChild(preview);
          	drop.parentNode.removeChild(drop);
          }
        </body>
      </method>
      
      <method name="ensureElementsAreVisible">
        <parameter name="first"/>
        <parameter name="last"/>
        <body>
        <![CDATA[
          var y = {};
          this.scrollBoxObject.getPosition({}, y);
          var scrollTop = y.value;
          var scrollHeight = this.scrollBox.boxObject.height;

          var eltop = first.boxObject.y;
          var style = window.getComputedStyle(first,null);
          eltop-=parseInt(style.marginTop)+parseInt(style.borderTopWidth);
          
          var elbottom = last.boxObject.y+last.boxObject.height;
          style = window.getComputedStyle(last,null);
          elbottom+=parseInt(style.marginBottom)+parseInt(style.borderBottomWidth);

          if (scrollTop>eltop)
          {
            this.scrollBoxObject.scrollBy(0,eltop-scrollTop);
          }
          else if ((scrollTop+scrollHeight)<elbottom)
          {
            var shift = elbottom-(scrollTop+scrollHeight);
            if ((scrollTop+shift)>eltop)
            {
              shift=eltop-scrollTop;
            }
            this.scrollBoxObject.scrollBy(0,shift);
          }
        ]]>
        </body>
      </method>
      
      <method name="scrollToPreview">
        <parameter name="preview"/>
        <body>
          this.ensureElementsAreVisible(preview.previousSibling,preview.nextSibling);
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.getPreviewForBrowser(browser);
        	if (this._selected)
        	{
            this._selected.selected=false;
        	}
        	if (preview)
        	{
          	preview.selected=true;
            this.scrollToPreview(preview);
          }
        	this._selected=preview;
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="updateContent">
        <body>
        <![CDATA[
          var hide = "";
          if (!this.showStop)
            hide+=" stop";
          if (!this.showForward)
            hide+=" forward";
          if (!this.showBack)
            hide+=" back";
          if (!this.showReload)
            hide+=" reload";
          if (!this.showURI)
            hide+=" uri";
          
          if (hide.length>0)
            hide=hide.substring(1);
          
          this.setAttribute("hide",hide);
        ]]>
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].redraw();
        	}
        ]]>
        </body>
      </method>
      
      <method name="browserResized">
        <parameter name="preview"/>
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
        <![CDATA[
          if (this.suppressSizing)
            return;

          if (this._selected == preview)
          {
            var newWidth=0;
            var newHeight=0;
  
            var container = preview.canvas.parentNode;
            var computed = window.getComputedStyle(container,null);
            newWidth = parseInt(computed.width);
            if (newWidth<0)
            {
              this._logError("Invalid canvas width ("+newWidth+")");
              this._resizeTimer.initWithCallback(this, 
                                                 5,
                                                 Components.interfaces.nsITimer.TYPE_ONE_SHOT);
              return;
            }
            else if (newWidth==0)
            {
              this._logWarning("Zero canvas width");
            }

            newHeight = parseInt((height/width)*newWidth);
  
            if (this._displayWidth!=newWidth || this._displayHeight!=newHeight)
            {
              this._contentWidth=newWidth;
              this._contentHeight=newHeight;
              this._displayWidth=newWidth;
              this._displayHeight=newHeight;
            	this._resize();
              this.style.visibility=null;
            }
          }
        ]]>
        </body>
      </method>
      
      <!-- Start of DnD implementation -->

      <field name="_lastDrop"/>
      
      <method name="_drawDropIndicator">
        <parameter name="drop"/>
        <body>
          if (drop!=this._lastDrop)
          {
            this.ensureElementsAreVisible(drop,drop);
            var y = {};
            this.scrollBoxObject.getPosition({}, y);
            var dropel = drop;
            if (drop.localName == "tabpreview")
            {
              dropel = drop.canvas.parentNode;
            }
            var pos = dropel.boxObject.y+(dropel.boxObject.height/2);
            pos = pos - y.value - 5;
            this.dragDropIndicator.style.marginTop = pos + "px";
            if (!this._lastDrop)
            {
              this.dragDropBar.setAttribute("dragging","true");
            }
            this._lastDrop=drop;
          }
        </body>
      </method>
      
      <method name="_hideDropIndicator">
        <body>
          if (this._lastDrop)
          {
            this._lastDrop=null;
            this.dragDropBar.setAttribute("dragging","false");
          }
        </body>
      </method>
      
      <method name="getDropElement">
        <parameter name="aEvent"/>
        <parameter name="external"/>
        <body>
        <![CDATA[
          var y = {};
          this.scrollBoxObject.getPosition({}, y);
          var ypos = aEvent.clientY+y.value;
          var diff = 0;
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
          {
            var bo = previews[i].boxObject;
            if (external)
            {
              if (bo.y>ypos)
              {
                return previews[i].previousSibling;
              }
              else if ((bo.y+bo.height)>=ypos)
              {
                return previews[i];
              }
            }
            else
            {
              if ((bo.y+(bo.height/2))>ypos)
              {
                return previews[i].previousSibling;
              }
            }
          }
          return previews[previews.length-1].nextSibling;
        ]]>
        </body>
      </method>
      
      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
        <![CDATA[
          try
          {
            if (aEvent.target.localName == "tabpreview" &&
                aEvent.originalTarget.localName != "toolbarbutton")
            {
              aXferData.data = new TransferData();
              
              var URI = aEvent.target._browser.currentURI;
              if (URI)
              {
                aXferData.data.addDataForFlavour("text/unicode", URI.spec);
                aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + aEvent.target.title);
                aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + aEvent.target.title + '</a>');
              }
              else
              {
                aXferData.data.addDataForFlavour("text/unicode", "about:blank");
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            var y = {};
            this.scrollBoxObject.getPosition({}, y);

            if (y.value>0 && aEvent.clientY<10)
            {
              this.scrollBoxObject.scrollBy(0,-20);
              this._hideDropIndicator();
              return;
            }
            
            var bottom = this.ownerDocument.getAnonymousNodes(this.scrollBox)[0].boxObject.height-this.scrollBox.boxObject.height;
            
            if ((this.scrollBox.boxObject.height-aEvent.clientY)<10 && y.value<bottom)
            {
              this.scrollBoxObject.scrollBy(0,20);
              this._hideDropIndicator();
              return;
            }
  
            if (!aDragSession.canDrop)
            {
              this._hideDropIndicator();
              return;
            }
              
            if (aDragSession.sourceNode &&
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var newpos = this.getDropElement(aEvent,false);

              var preview = null;
              if (aDragSession.sourceNode.parentNode == this)
              {
                preview = aDragSession.sourceNode;              
              }
              else
              {
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              }
              
              if (newpos == preview.previousSibling || newpos == preview.nextSibling)
              {
                aDragSession.canDrop=false;
                this._hideDropIndicator();
              }
              else
              {
                this._drawDropIndicator(newpos);
              }
            }
            else
            {
              if (aEvent.target.localName=="tabpreview")
              {
                this._drawDropIndicator(aEvent.target);
              }
              else
              {
                var newpos = this.getDropElement(aEvent,true);
                this._drawDropIndicator(newpos);
              }
            }
          }
          catch (e)
          {
            dump(e+"\n");
          }
        ]]>
        </body>
      </method>

      <method name="movePreview">
        <parameter name="preview"/>
        <parameter name="insertBefore"/>
        <body>
        <![CDATA[
          var newIndex = this.previews.length;
          if (insertBefore)
          {
            newIndex = insertBefore.tab._tPos;
          }
          
          var oldIndex = preview.tab._tPos;
          
          if (newIndex>oldIndex)
            newIndex--;
            
          if (newIndex==oldIndex)
            return;

          var focus=false;
          if (this.ownerDocument.commandDispatcher.focusedElement && this.ownerDocument.commandDispatcher.focusedElement==preview)
            focus=true;
          
          this.tabbrowser.moveTabTo(preview.tab, newIndex);
            preview.focus();
        ]]>
        </body>
      </method>
      
      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (aDragSession.sourceNode && 
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var preview = null
              if (aDragSession.sourceNode.parentNode == this)
              {
                preview = aDragSession.sourceNode;              
              }
              else
              {
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              }
              
              var target = this.getDropElement(aEvent,false);
              this.movePreview(preview,target.nextSibling);
            }
            else
            {
              var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);
  
              // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
              // Also disallow dropping javascript: or data: urls--bail out
              if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
                  /^\s*(javascript|data):/.test(url))
                return;
  
              this.tabbrowser.dragDropSecurityCheck(aEvent, aDragSession, url);
  
              var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                    .getService(Components.interfaces.nsIPrefService);
              var bgLoad = true;
              try
              {
                bgLoad = prefs.getBoolPref("browser.tabs.loadInBackground");
              }
              catch (e) { }
  
              if (aEvent.shiftKey)
                bgLoad = !bgLoad;
  
              if (aEvent.target.localName != "tabpreview")
              {
                // We're adding a new tab.
                var move = false;
                var newIndex = this.previews.length;
                var target = this.getDropElement(aEvent,false);
                if (target.nextSibling)
                {
                  target = target.nextSibling;
                  newIndex = target.tab._tPos;
                  move = true;
                }
  
                var newtab = this.tabbrowser.loadOneTab(url, null, null, null, bgLoad);
                
                if (move)
                  this.tabbrowser.moveTabTo(newtab, newIndex);
              }
              else
              {
                // Load in an existing tab.
                var preview = aEvent.target;
                preview.browser.loadURI(url);
  
                if (this.tabbrowser.selectedTab != preview.tab && !bgLoad)
                  this.tabbrowser.selectedTab = preview.tab;
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (!aEvent.relatedTarget && this._lastDrop)
            {
              this._hideDropIndicator();
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("text/x-moz-url");
          flavourSet.appendFlavour("text/unicode");
          flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
          return flavourSet;
        ]]>
        </body>
      </method>

      <!-- Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._resizeTimer)
          {
            if (this.displayHeight<=0)
            {
              this._selected._updateSize(false);
            }
          }
        ]]>
        </body>
      </method>
      
      <!-- Start of nsIObserver implementation -->

      <method name="observe">
        <parameter name="subject"/>
        <parameter name="topic"/>
        <parameter name="data"/>
        <body>
        <![CDATA[
          switch (data)
          {
            case "content.reload":
              this._showReload = this.preferences.getBoolPref(data);
              this.updateContent();
              break;
            case "content.stop":
              this._showStop = this.preferences.getBoolPref(data);
              this.updateContent();
              break;
            case "content.forward":
              this._showForward = this.preferences.getBoolPref(data);
              this.updateContent();
              break;
            case "content.back":
              this._showBack = this.preferences.getBoolPref(data);
              this.updateContent();
              break;
            case "content.uri":
              this._showURI = this.preferences.getBoolPref(data);
              this.updateContent();
              break;
              
            case "enablelogging":
              this._enableLogging = this.preferences.getBoolPref(data);
              break;
            case "loadrefresh":
              this._loadRefresh = this.preferences.getBoolPref(data);
              break;
            case "loadrefreshrate":
              this._loadRefreshRate = this.preferences.getIntPref(data);
              break;
            case "loaddelay":
              this._loadDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedloaddelay":
              this._unselectedLoadDelay = this.preferences.getIntPref(data);
              break;
            case "scrolldelay":
              this._scrollDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedscrolldelay":
              this._unselectedScrollDelay = this.preferences.getIntPref(data);
              break;
            case "textdelay":
              this._textDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedtextdelay":
              this._unselectedTextDelay = this.preferences.getIntPref(data);
              break;
            case "changedelay":
              this._changeDelay = this.preferences.getIntPref(data);
              break;
            case "unselectedchangedelay":
              this._unselectedChangeDelay = this.preferences.getIntPref(data);
              break;
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      
      <handler event="click">
        if (event.button == 2)
        {
          var x = this.boxObject.screenX-this.window.document.documentElement.boxObject.screenX+event.clientX;
          var y = this.boxObject.screenY-this.window.document.documentElement.boxObject.screenY+event.clientY;

          x+=2;
          y+=2;
          
          var tab = null;
          if (event.target.localName == "tabpreview")
          {
            tab = event.target.tab;
          }
          else
          {
            tab = this._selected.tab;
          }
          this.tabbrowser.ownerDocument.popupNode = tab;
          var context = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"anonid","tabContextMenu");
          context.showPopup(tab,x,y,"context");
        }
      </handler>
      
      <handler event="dblclick">
      <![CDATA[
        if (event.button==0 && (event.target.localName=="separator" || event.target == this))
        {
          var focus = false;
          if (document.commandDispatcher.focusedElement==this._selected)
          {
            focus=true;
            this._selected.tab.focus();
          }

          var move = false;
          var newIndex = this.previews.length;
          var target = this.getDropElement(event,false);
          if (target.nextSibling)
          {
            target = target.nextSibling;
            newIndex = target.tab._tPos;
            move = true;
          }
  
					var newtab = this.tabbrowser.addTab("about:blank");

          if (move)
            this.tabbrowser.moveTabTo(newtab, newIndex);

					this.tabbrowser.selectedTab = newtab;

					var urlbar = this.window.document.getElementById("urlbar");

					if (focus)
            this._selected.focus();
          else
						setTimeout(function() { urlbar.focus(); }, 0);
        }
      ]]>
      </handler>
      
      <handler event="focus">
        if (event.originalTarget==this.focusDetector)
        {
          if (this._selected)
            this._selected.focus();
        }
        else if (event.target.parentNode==this)
        {
          this.focusDetector.style.MozUserFocus="ignore";
        }
      </handler>
      
      <handler event="blur">
        if (event.target.parentNode==this)
        {
          this.focusDetector.style.MozUserFocus="normal";
        }
      </handler>
      
      <handler event="popupshowing">
      <![CDATA[
        if (event.originalTarget.id=="tabpreview_tooltip")
        {
          var preview = this.ownerDocument.tooltipNode;
          while (preview.localName!="tabpreview")
          {
            preview=preview.parentNode;
          }
          event.originalTarget.childNodes[0].value=preview.title;
          event.originalTarget.childNodes[1].value=preview.uri;
        }
      ]]>
      </handler>

      <handler event="keypress">
      <![CDATA[
        if (event.target.parentNode==this)
        {
          var preview = event.target;
          if (event.altKey||event.shiftKey||event.metaKey)
          {
            return;
          }
          else if (event.ctrlKey)
          {
            if (event.keyCode==event.DOM_VK_UP)
            {
              var newpreview = preview.previousSibling.previousSibling;
              if (newpreview)
              {
                this.movePreview(preview,newpreview);
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_DOWN)
            {
              var newpreview = preview.nextSibling.nextSibling;
              if (newpreview)
              {
                this.movePreview(preview,newpreview.nextSibling.nextSibling);
              }
              event.preventDefault();
            }
          }
          else
          {
            if (event.keyCode==event.DOM_VK_UP)
            {
              var newpreview = preview.previousSibling.previousSibling;
              if (newpreview)
              {
                preview.tab.focus();
                this.tabbrowser.selectedTab=newpreview.tab;
                newpreview.focus();
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_DOWN)
            {
              var newpreview = preview.nextSibling.nextSibling;
              if (newpreview)
              {
                preview.tab.focus();
                this.tabbrowser.selectedTab=newpreview.tab;
                newpreview.focus();
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_PAGE_UP)
            {
              var compare = preview.previousSibling.previousSibling;
              if (compare)
              {
                var diff = preview.boxObject.y-compare.boxObject.y;
                var height = this.scrollBox.boxObject.height;
                var jump = height/diff;
                var current = preview;
                var count = 1;
                while ((count<=jump)&&(current.previousSibling.previousSibling))
                {
                  current=current.previousSibling.previousSibling;
                  count++;
                }
                preview.tab.focus();
                this.tabbrowser.selectedTab=current.tab;
                current.focus();
              }
              event.preventDefault();
            }
            else if (event.keyCode==event.DOM_VK_PAGE_DOWN)
            {
              var compare = preview.nextSibling.nextSibling;
              if (compare)
              {
                var diff = compare.boxObject.y-preview.boxObject.y;
                var height = this.scrollBox.boxObject.height;
                var jump = height/diff;
                var current = preview;
                var count = 1;
                while ((count<=jump)&&(current.nextSibling.nextSibling))
                {
                  current=current.nextSibling.nextSibling;
                  count++;
                }
                preview.tab.focus();
                this.tabbrowser.selectedTab=current.tab;
                current.focus();
              }
              event.preventDefault();
            }
          }
        }
      ]]>
      </handler>
    </handlers>

  </binding>
  
</bindings>
