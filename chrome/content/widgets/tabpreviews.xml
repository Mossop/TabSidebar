<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings [
<!ENTITY % tabbrowserDTD SYSTEM "chrome://global/locale/tabbrowser.dtd" >
<!ENTITY % tabSidebarDTD SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd" >
%tabbrowserDTD;
%tabSidebarDTD;
]>

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/widgets/tabpreviews.css"/>
    </resources>
    
    <content hide="" orient="horizontal" align="stretch" flex="1">
      <xul:popupset>
      
        <xul:tooltip id="tabpreview_tooltip" orient="vertical">
          <xul:label value="Title"/>
          <xul:label style="display: none" value="URI"/>
        </xul:tooltip>
        
      </xul:popupset>
      
      <xul:vbox class="tab-drop-indicator-bar">
        <xul:hbox class="tab-drop-indicator"/>
      </xul:vbox>          

      <xul:scrollbox allowevents="true" anonid="scrollbox"
                     ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode); event.stopPropagation();"
                     ondragover="nsDragAndDrop.dragOver(event, this.parentNode); event.stopPropagation();"
                     ondragdrop="nsDragAndDrop.drop(event, this.parentNode); event.stopPropagation();"
                     ondragexit="nsDragAndDrop.dragExit(event, this.parentNode); event.stopPropagation();"
                     align="stretch" orient="vertical" flex="1">
        

        <children/>

      </xul:scrollbox>
    </content>
    
    <implementation implements="nsITimerCallback,nsIObserver">
    
      <constructor>
      <![CDATA[
        var topwin = window;
        while (topwin.parent && topwin.parent != topwin)
        {
          topwin=topwin.parent;
        }
        this.window = topwin;
        this.tabbrowser = topwin.document.getElementById("content");
        
        this._loadLocale();
        this._initTree();
        this._migrateOldSettings();
        this._initSettings();
        
        var browsers = this.tabbrowser.browsers;
        for (var i=0; i<browsers.length; i++)
        {
          this.addPreview(browsers[i]);
        }
        
        this._initEvents();
      ]]>
      </constructor>
      
      <method name="_loadLocale">
        <body>
          var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"]
                              .getService(Components.interfaces.nsIStringBundleService);
          var bundle = sbs.createBundle("chrome://browser/locale/browser.properties");
        </body>
      </method>
      
      <method name="_initTree">
        <body>
        	var drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
        	drop.className="dropindicator groove";
        	drop.setAttribute("orient","horizontal");
          this.previewContainer.appendChild(drop);
        </body>
      </method>

      <method name="_migrateOldSettings">
        <body>
          if (this.preferences.prefHasUserValue("content.buttons"))
          {
            var state = this.preferences.getBoolPref("content.buttons");
            this.preferences.setBoolPref("content.reload",state);
            this.preferences.setBoolPref("content.throbber",state);
            this.preferences.setBoolPref("content.close",state);
            this.preferences.clearUserPref("content.buttons");
          }
        </body>
      </method>

      <method name="_initSettings">
        <body>
          if (this.autoRefresh)
          {
            this._refreshTimer.initWithCallback(this, 
                                                this.refreshRate,
                                                Components.interfaces.nsITimer.TYPE_REPEATING_SLACK)
          }
          this.updateContent();        
        </body>
      </method>
      
      <method name="_initEvents">
        <body>
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranchInternal);
          prefs.addObserver("tabsidebar.", this, false);
        
        	var self=this;
        	this._eventListener = function(event) { self.eventFilter(event); };
        	
        	this.tabbrowser.tabContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
        	var container = this.tabbrowser.mPanelContainer;
        	container.addEventListener("select", this._eventListener, false);
        	container.addEventListener("DOMNodeInserted", this._eventListener, false);
        	container.addEventListener("DOMNodeRemoved", this._eventListener, false);
        </body>
      </method>
      
      <destructor>
      	this.tabbrowser.tabContainer.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.removeEventListener("select", this._eventListener, false);
      	container.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	container.removeEventListener("DOMNodeRemoved", this._eventListener, false);

        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranchInternal);
        prefs.removeObserver("tabsidebar.", this);
      </destructor>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener"/>

      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          if (event.type=="DOMNodeInserted")
          {
        		if (event.relatedNode==this.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.addPreview(browser);
        		}
        		else if (event.relatedNode==this.tabbrowser.tabContainer)
        		{
        		  var browser = event.target.linkedBrowser;
        		  if (browser)
        		  {
        		    this.movePreview(browser);
        		  }
        		}
          }
          else if (event.type=="DOMNodeRemoved")
          {
        		if (event.relatedNode==this.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.removePreview(browser);
        		}
          }
          else if (event.type=="select")
          {
        		var newBrowser = this.tabbrowser.getBrowserAtIndex(this.tabbrowser.mTabContainer.selectedIndex);
        		this.selectPreview(newBrowser);
          }
        </body>
      </method>
      
      <!-- Internal fields and methods -->

      <field name="_selected"/>

      <field name="_refreshTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>

      <method name="_resize">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i]._resize();
        	}
        	this.redraw();
        ]]>
        </body>
      </method>

      <!-- Helper properties -->

      <field name="preferences">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefService)
                  .getBranch("tabsidebar.");
      </field>
      <field name="tabbrowser"/>
      <field name="window"/>
      <field name="previewContainer">this</field>
      <field name="scrollBox">this.ownerDocument.getAnonymousNodes(this)[2]</field>
      <field name="scrollBoxObject">this.scrollBox.boxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject)</field>
      <field name="dragDropBar">this.ownerDocument.getAnonymousNodes(this)[1]</field>
      <field name="dragDropIndicator">this.dragDropBar.firstChild;</field>
      
      <property name="previews">
        <getter>
          return this.ownerDocument.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

      <property name="showReload">
        <getter>
          return this.preferences.getBoolPref("content.reload");
        </getter>
      </property>
      
      <property name="showClose">
        <getter>
          return this.preferences.getBoolPref("content.close");
        </getter>
      </property>
      
      <property name="showFavicon">
        <getter>
          return this.preferences.getBoolPref("content.favicon");
        </getter>
      </property>
      
      <property name="showThrobber">
        <getter>
          return this.preferences.getBoolPref("content.throbber");
        </getter>
      </property>
      
      <property name="showSecurity">
        <getter>
          return this.preferences.getBoolPref("content.security");
        </getter>
      </property>
      
      <property name="showPreview">
        <getter>
        <![CDATA[
          return this.preferences.getBoolPref("content.preview");
        ]]>
        </getter>
      </property>
      
      <property name="showTitle">
        <getter>
          return this.preferences.getBoolPref("content.title");
        </getter>
      </property>
      
      <property name="showURI">
        <getter>
          return this.preferences.getBoolPref("content.uri");
        </getter>
      </property>
      
      <field name="_displayWidth">-1</field>
      <property name="displayWidth">
        <getter>
          return this._displayWidth;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._displayWidth)
            return val;

          this._displayWidth=val;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_displayHeight">-1</field>
      <property name="displayHeight">
        <getter>
          return this._displayHeight;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._displayHeight)
            return val;

          this._displayHeight=val;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_contentWidth">-1</field>
      <property name="contentWidth">
        <getter>
          return this._contentWidth;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._contentWidth)
            return val;

          this._contentWidth=val;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_contentHeight">-1</field>
      <property name="contentHeight">
        <getter>
          return this._contentHeight;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._contentHeight)
            return val;

          this._contentHeight=val;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_suppressSizing">false</field>
      <property name="suppressSizing">
        <getter>
          return this._suppressSizing;
        </getter>
        <setter>
          if (this._suppressSizing != val)
          {
            this._suppressSizing = val;
            this.browserResized(this._selected._browser.contentWindow.innerWidth,this._selected._browser.contentWindow.innerHeight);
          }
          return val;
        </setter>
      </property>

      <property name="autoRefresh">
        <getter>
          return this.preferences.getBoolPref("autorefresh");
        </getter>
      </property>
      
      <property name="refreshRate">
        <getter>
          return Math.max(5,this.preferences.getIntPref("refreshrate"))*1000;
        </getter>
      </property>
      
      <property name="loadRefresh">
        <getter>
          return this.preferences.getBoolPref("loadrefresh");
        </getter>
      </property>
      
      <property name="loadRefreshRate">
        <getter>
          return Math.max(100,this.preferences.getIntPref("loadrefreshrate"));
        </getter>
      </property>
      
      <property name="loadDelay">
        <getter>
          return this.preferences.getIntPref("loaddelay");
        </getter>
      </property>
      
      <property name="drawScrolled">
        <getter>
          return this.preferences.getBoolPref("drawscrolled");
        </getter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = this.ownerDocument.getElementById(browser.parentNode.id);
        	if (preview)
        	{
        		return preview;
        	}
        	var id=browser.parentNode.id;
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		var preview = previews[i];
        		if (preview.browser==browser)
        		{
          		if (id)
          		{
          		  preview.id=id;
          		}
        		  return preview;
        		}
        	}
        	return null;
        ]]>
        </body>
      </method>
      
      <method name="getTabForPreview">
        <parameter name="preview"/>
        <body>
          var tabbrowser = this.tabbrowser;
          var panel = preview._browser.parentNode.id;
          return tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.ownerDocument.createElement("tabpreview");
        	var drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
        	drop.className="dropindicator groove";
        	drop.setAttribute("orient","horizontal");
        	var id=browser.parentNode.id;
        	if (id)
        	{
        		preview.id=id;
        	}
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
        	if (tab && tab.nextSibling)
        	{
        		var next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
        		if (next)
        		{
          		this.previewContainer.insertBefore(preview,next);
          		this.previewContainer.insertBefore(drop,next);
          	}
          	else
          	{
              this.previewContainer.appendChild(preview);
              this.previewContainer.appendChild(drop);
          	}
        	}
        	else
        	{
        		this.previewContainer.appendChild(preview);
        		this.previewContainer.appendChild(drop);
        	}
        	preview.init();
        	preview.browser=browser;
        	
        	if (this.tabbrowser.selectedBrowser==browser)
        	{
        	  this.selectPreview(browser);
        	}
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
        	var preview = this.getPreviewForBrowser(browser);
        	preview.browser=null;
        	var drop = preview.nextSibling;
        	preview.parentNode.removeChild(preview);
        	drop.parentNode.removeChild(drop);
        </body>
      </method>
      
      <method name="movePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          if (preview)
          {
            this.removePreview(browser);
            this.addPreview(browser);
          }
        </body>
      </method>
      
      <method name="ensureElementsAreVisible">
        <parameter name="first"/>
        <parameter name="last"/>
        <body>
        <![CDATA[
          var y = {};
          this.scrollBoxObject.getPosition({}, y);
          var scrollTop = y.value;
          var scrollHeight = this.scrollBox.boxObject.height;

          var eltop = first.boxObject.y;
          var style = window.getComputedStyle(first,null);
          eltop-=parseInt(style.marginTop);
          
          var elbottom = last.boxObject.y+last.boxObject.height;
          style = window.getComputedStyle(last,null);
          elbottom+=parseInt(style.marginTop);

          if (scrollTop>eltop)
          {
            this.scrollBoxObject.scrollBy(0,eltop-scrollTop);
          }
          else if ((scrollTop+scrollHeight)<elbottom)
          {
            var shift = elbottom-(scrollTop+scrollHeight);
            if ((scrollTop+shift)>eltop)
            {
              shift=eltop-scrollTop;
            }
            this.scrollBoxObject.scrollBy(0,shift);
          }
        ]]>
        </body>
      </method>
      
      <method name="scrollToPreview">
        <parameter name="preview"/>
        <body>
          this.ensureElementsAreVisible(preview.previousSibling,preview.nextSibling);
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.getPreviewForBrowser(browser);
        	if (this._selected)
        	{
            this._selected.setAttribute("selected","false");
        	}
        	if (preview)
        	{
          	preview.setAttribute("selected","true");
          }
        	this._selected=preview;
        	this.scrollToPreview(preview);
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="updateContent">
        <body>
        <![CDATA[
          var canvasWasHidden=false;
          var hide = this.getAttribute("hide");
          if (hide.indexOf("preview")>=0)
            canvasWasHidden=true;
          
          hide = "";
          if (!this.showThrobber)
            hide+=" throbber";
          if (!this.showFavicon)
            hide+=" favicon";
          if (!this.showReload)
            hide+=" reload";
          if (!this.showClose)
            hide+=" close";
          if (!this.showPreview)
            hide+=" preview";
          if (!this.showTitle)
            hide+=" title";
          if (!this.showURI)
            hide+=" uri";
          if (!this.showSecurity)
            hide+=" security";
          
          if (hide.length>0)
            hide=hide.substring(1);
          
          this.setAttribute("hide",hide);

        	if (canvasWasHidden && this.showPreview)
        	{
        	  this._resize();
        	}
        ]]>
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].redraw();
        	}
        ]]>
        </body>
      </method>
      
      <method name="browserResized">
        <parameter name="width"/>
        <parameter name="height"/>
        <body>
        <![CDATA[
          if (this.suppressSizing)
            return true;

          var newWidth=0;
          var newHeight=0;

          var container = this.ownerDocument.getAnonymousElementByAttribute(this.previews[0],"anonid","canvas_container");
          var computed = window.getComputedStyle(container,null);
          newWidth = parseInt(computed.width);
          if (newWidth<0)
          {
            newWidth=0;
          }
          newHeight = parseInt((height/width)*newWidth);

          if (this._displayWidth!=newWidth || this._displayHeight!=newHeight)
          {
            this._contentWidth=newWidth;
            this._contentHeight=newHeight;
            this._displayWidth=newWidth;
            this._displayHeight=newHeight;
          	this._resize();
          	return true;
          }
          return false;
        ]]>
        </body>
      </method>
      
      <!-- Start of DnD implementation -->

      <field name="_lastDrop"/>
      
      <method name="_drawDropIndicator">
        <parameter name="drop"/>
        <body>
          if (drop!=this._lastDrop)
          {
            this.ensureElementsAreVisible(drop,drop);
            var y = {};
            this.scrollBoxObject.getPosition({}, y);
            var pos = drop.boxObject.y+(drop.boxObject.height/2)-5;
            pos = pos - y.value;
            this.dragDropIndicator.style.marginTop = pos + "px";
            if (!this._lastDrop)
            {
              this.dragDropBar.setAttribute("dragging","true");
            }
            this._lastDrop=drop;
          }
        </body>
      </method>
      
      <method name="_hideDropIndicator">
        <body>
          if (this._lastDrop)
          {
            this._lastDrop=null;
            this.dragDropBar.setAttribute("dragging","false");
          }
        </body>
      </method>
      
      <method name="getDropElement">
        <parameter name="aEvent"/>
        <parameter name="external"/>
        <body>
        <![CDATA[
          var y = {};
          this.scrollBoxObject.getPosition({}, y);
          var ypos = aEvent.clientY+y.value;
          var diff = 0;
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
          {
            var bo = previews[i].boxObject;
            if (external)
            {
              if (bo.y>ypos)
              {
                return previews[i].previousSibling;
              }
              else if ((bo.y+bo.height)>=ypos)
              {
                return previews[i];
              }
            }
            else
            {
              if ((bo.y+(bo.height/2))>ypos)
              {
                return previews[i].previousSibling;
              }
            }
          }
          return previews[previews.length-1].nextSibling;
        ]]>
        </body>
      </method>
      
      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
        <![CDATA[
          try
          {
            if (aEvent.target.localName == "tabpreview" &&
                aEvent.originalTarget.localName != "toolbarbutton")
            {
              aXferData.data = new TransferData();
              
              var URI = aEvent.target._browser.currentURI;
              if (URI)
              {
                aXferData.data.addDataForFlavour("text/unicode", URI.spec);
                aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + aEvent.target.title);
                aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + aEvent.target.title + '</a>');
              }
              else
              {
                aXferData.data.addDataForFlavour("text/unicode", "about:blank");
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            var y = {};
            this.scrollBoxObject.getPosition({}, y);

            if (y.value>0 && aEvent.clientY<10)
            {
              this.scrollBoxObject.scrollBy(0,-20);
              this._hideDropIndicator();
              return;
            }
            
            var bottom = this.ownerDocument.getAnonymousNodes(this.scrollBox)[0].boxObject.height-this.scrollBox.boxObject.height;
            
            if ((this.scrollBox.boxObject.height-aEvent.clientY)<10 && y.value<bottom)
            {
              this.scrollBoxObject.scrollBy(0,20);
              this._hideDropIndicator();
              return;
            }
  
            if (!aDragSession.canDrop)
            {
              this._hideDropIndicator();
              return;
            }
              
            if (aDragSession.sourceNode &&
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var newpos = this.getDropElement(aEvent,false);

              var preview = null;
              if (aDragSession.sourceNode.parentNode == this)
              {
                preview = aDragSession.sourceNode;              
              }
              else
              {
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              }
              
              if (newpos == preview.previousSibling || newpos == preview.nextSibling)
              {
                aDragSession.canDrop=false;
                this._hideDropIndicator();
              }
              else
              {
                this._drawDropIndicator(newpos);
              }
            }
            else
            {
              if (aEvent.target.localName=="tabpreview")
              {
                this._drawDropIndicator(aEvent.target);
              }
              else
              {
                var newpos = this.getDropElement(aEvent,true);
                this._drawDropIndicator(newpos);
              }
            }
          }
          catch (e)
          {
            dump(e+"\n");
          }
        ]]>
        </body>
      </method>

      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (aDragSession.sourceNode && 
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var preview = null
              if (aDragSession.sourceNode.parentNode == this)
              {
                preview = aDragSession.sourceNode;              
              }
              else
              {
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              }
              
              var newIndex = this.previews.length;
              var target = this.getDropElement(aEvent,false);
              if (target.nextSibling)
              {
                target = target.nextSibling;
                newIndex = target.tab._tPos;
              }
              
              var previews = this.previews;
              var oldIndex = preview.tab._tPos;
              
              if (newIndex>oldIndex)
                newIndex--;
                
              if (newIndex==oldIndex)
                return;
  
              this.tabbrowser.moveTabTo(preview.tab, newIndex);
            }
            else
            {
              var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);
  
              // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
              // Also disallow dropping javascript: or data: urls--bail out
              if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
                  /^\s*(javascript|data):/.test(url))
                return;
  
              this.tabbrowser.dragDropSecurityCheck(aEvent, aDragSession, url);
  
              var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                    .getService(Components.interfaces.nsIPrefService);
              var bgLoad = true;
              try
              {
                bgLoad = prefs.getBoolPref("browser.tabs.loadInBackground");
              }
              catch (e) { }
  
              if (aEvent.shiftKey)
                bgLoad = !bgLoad;
  
              if (aEvent.target.localName != "tabpreview")
              {
                // We're adding a new tab.
                var move = false;
                var newIndex = this.previews.length;
                var target = this.getDropElement(aEvent,false);
                if (target.nextSibling)
                {
                  target = target.nextSibling;
                  newIndex = target.tab._tPos;
                  move = true;
                }
  
                var newtab = this.tabbrowser.loadOneTab(url, null, null, null, bgLoad);
                
                if (move)
                  this.tabbrowser.moveTabTo(newtab, newIndex);
              }
              else
              {
                // Load in an existing tab.
                var preview = aEvent.target;
                preview.browser.loadURI(url);
  
                if (this.tabbrowser.selectedTab != preview.tab && !bgLoad)
                  this.tabbrowser.selectedTab = preview.tab;
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (!aEvent.relatedTarget && this._lastDrop)
            {
              this._hideDropIndicator();
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("text/x-moz-url");
          flavourSet.appendFlavour("text/unicode");
          flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
          return flavourSet;
        ]]>
        </body>
      </method>

      <!-- Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._refreshTimer)
          {
            this.redraw();
          }
        ]]>
        </body>
      </method>
      
      <!-- Start of nsIObserver implementation -->

      <method name="observe">
        <parameter name="subject"/>
        <parameter name="topic"/>
        <parameter name="data"/>
        <body>
        <![CDATA[
          data=data.substring(11);
          switch (data)
          {
            case "content.favicon":
            case "content.preview":
            case "content.close":
            case "content.security":
            case "content.reload":
            case "content.throbber":
            case "content.title":
            case "content.uri":
              this.updateContent();
              break;
            case "refreshrate":
            case "autorefresh":
              this._refreshTimer.cancel();
              if (this.autoRefresh)
              {
                this._refreshTimer.initWithCallback(this, 
                                                    this.refreshRate,
                                                    Components.interfaces.nsITimer.TYPE_REPEATING_SLACK)
              }
              break;
            case "drawscrolled":
              this.redraw();
              break;
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      
      <handler event="click">
        if (event.button == 2)
        {
          var x = this.boxObject.screenX-this.window.document.documentElement.boxObject.screenX+event.clientX;
          var y = this.boxObject.screenY-this.window.document.documentElement.boxObject.screenY+event.clientY;

          var tab = null;
          if (event.target.localName == "tabpreview")
          {
            tab = event.target.tab;
          }
          else
          {
            tab = this._selected.tab;
          }
          this.tabbrowser.ownerDocument.popupNode = tab;
          var context = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"anonid","tabContextMenu");
          context.showPopup(tab,x,y,"context");
        }
      </handler>
      
      <handler event="dblclick">
      <![CDATA[
        if (event.button==0 && (event.target.localName=="separator" || event.target == this))
        {
          var newTab = this.tabbrowser.addTab("about:blank");
          this.tabbrowser.selectedTab=newTab;
        }
      ]]>
      </handler>
      
      <handler event="popupshowing">
      <![CDATA[
        if (event.originalTarget.id=="tabpreview_tooltip")
        {
          var preview = this.ownerDocument.tooltipNode;
          while (preview.localName!="tabpreview")
          {
            preview=preview.parentNode;
          }
          event.originalTarget.childNodes[0].value=preview.title;
          event.originalTarget.childNodes[1].value=preview.uri;
        }
      ]]>
      </handler>

    </handlers>

  </binding>
  
</bindings>
