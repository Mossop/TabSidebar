<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings [
<!ENTITY % tabSidebarDTD SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd" >
%tabSidebarDTD;
]>

<bindings id="TabSidebarBindings2"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreview" name="tabpreview">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/tabpreviews.css"/>
    </resources>
    
    <content orient="vertical" align="stretch" selected="false" loading="false" security="none">
      <xul:hbox align="center" anonid="topbox">
        <xul:toolbarbutton anonid="reload" tooltiptext="&tabsidebar.reload.tooltip;"/>
        <xul:image anonid="loading"/>
        <xul:label tooltip="tabpreview_tooltip" flex="1" anonid="title" crop="end" style="text-align: center"/>
        <xul:toolbarbutton anonid="close" tooltiptext="&tabsidebar.close.tooltip;"/>
      </xul:hbox>
      <xul:hbox align="stretch">
        <xul:vbox anonid="leftstrip" class="sidestrip" pack="end">
        </xul:vbox>
        <xul:box tooltip="tabpreview_tooltip" flex="1" anonid="canvas_container">
          <xhtml:canvas flex="1" anonid="canvas" tooltip="tabpreview_tooltip"/>
        </xul:box>
        <xul:vbox anonid="rightstrip" class="sidestrip" pack="end">
          <xul:image anonid="security"/>
        </xul:vbox>
      </xul:hbox>
      <xul:vbox tooltip="tabpreview_tooltip" align="stretch" anonid="bottombox">
        <xul:label anonid="uri" crop="end" style="text-align: center"/>
      </xul:vbox>
    </content>

    <implementation implements="nsIWebProgressListener,nsITimerCallback">

      <constructor>
      </constructor>

      <destructor>
        if (this._browser)
        {
          this._removeListeners();
        }
      </destructor>
      
      <method name="init">
        <body>
          this._resize();
        </body>
      </method>
      
      <!-- Event handling gubbins -->
      
      <field name="_eventListener"/>
      
      <method name="_addListeners">
        <body>
          if (!this._eventListener)
          {
            var self = this;
            this._eventListener = function(event) { self.eventFilter(event); };
          }
          this._browser.addEventListener("DOMTitleChanged", this._eventListener,false);
          var WP = Components.interfaces.nsIWebProgress;
          var mask = WP.NOTIFY_STATE_DOCUMENT | WP.NOTIFY_STATUS | WP.NOTIFY_LOCATION | WP.NOTIFY_SECURITY;
          this._browser.webProgress.addProgressListener(this._progressListener,mask);
        </body>
      </method>
      
      <method name="_removeListeners">
        <body>
          this._browser.webProgress.removeProgressListener(this._progressListener);
          this._browser.removeEventListener("DOMTitleChanged",this._eventListener,false);
        </body>
      </method>
      
      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          var previews = this.ownerDocument.getElementsByTagName("tabpreviews")[0];
          if (event.type=="DOMTitleChanged")
          {
            var preview = previews.getPreviewForBrowser(event.currentTarget);
            preview.update();
          }
        </body>
      </method>
      
      <field name="_progressListener">({
          tabpreview: this,

          onProgressChange : function (aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress)
          {
            this.tabpreview.onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress);
          },

          onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
          {
            this.tabpreview.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
          },

          onLocationChange : function(aWebProgress, aRequest, aLocation)
          {
            this.tabpreview.onLocationChange(aWebProgress, aRequest, aLocation);
          },

          onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
          {
            this.tabpreview.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
          },

          onSecurityChange : function(aWebProgress, aRequest, aState)
          {
            this.tabpreview.onSecurityChange(aWebProgress, aRequest, aState);
          },

          QueryInterface : function(aIID)
          {
            if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                aIID.equals(Components.interfaces.nsISupports))
              return this;
            throw Components.results.NS_NOINTERFACE;
          }
        });</field>
      <field name="_resizeListener"/>

      <!-- Internal fields and methods -->
      
      <field name="_redrawTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_loadTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>
      
      <field name="_browser"></field>
      <property name="browser">
        <getter>
          return this._browser;
        </getter>
        <setter>
          if (this._browser)
          {
            this._removeListeners();
          }
          this._browser=val;
          if (val)
          {
            this._addListeners();
            if (this._browser.securityUI)
            {
              this._setSecurity(val.securityUI.state);
            }
          }
          this.update();
          this.redraw();
          return val;
        </setter>
      </property>

      <method name="_resize">
        <body>
        <![CDATA[
          var canvas = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","canvas");
          canvas.setAttribute("width",this.previews.previewWidth);
          canvas.setAttribute("height",this.previews.previewHeight);
          //canvas.style.width=this.previews.previewWidth+"px";
          canvas.style.height=this.previews.previewHeight+"px";
        ]]>
        </body>
      </method>
      
      <method name="_loadStarted">
        <body>
          this.loading=true;
          var reload = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","reload");
          reload.disabled=true;
          this._redrawTimer.cancel();
          this._loadTimer.cancel();
          if (this.previews.loadRefresh)
          {
            this._loadTimer.initWithCallback(this, 
                                             this.previews.loadRefreshRate, 
                                             Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
          }
        </body>
      </method>
      
      <method name="_loadComplete">
        <body>
          this._loadTimer.cancel();
          var delay = this.previews.loadDelay;
          if (delay==0)
          {
            this.loading=false;
            this.update();
            this.redraw();
          }
          else
          {
            this._redrawTimer.initWithCallback(this, delay, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
          }
        </body>
      </method>
      
      <method name="_setSecurity">
        <parameter name="state"/>
        <body>
          const WPL = Components.interfaces.nsIWebProgressListener;
                       
          switch (state)
          {
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_HIGH:
              this.setAttribute("security", "high");
              break;
            case WPL.STATE_IS_SECURE | WPL.STATE_SECURE_LOW:
              this.setAttribute("security", "low");
              break;
            case WPL.STATE_IS_BROKEN:
              this.setAttribute("security", "broken");
              break;
            case WPL.STATE_IS_INSECURE:
            default:
              this.setAttribute("security", "none");
              break;
          }
          
          var icon = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","security");
          if (this._browser.securityUI)
          {
            icon.setAttribute("tooltiptext",this._browser.securityUI.tooltipText);
          }
          else
          {
            icon.removeAttribute("tooltiptext");
          }
        </body>
      </method>
      
      <!-- Helper properties -->
      
      <property name="previews">
        <getter>
          return this.parentNode;
        </getter>
      </property>
      
      <property name="tab">
        <getter>
          return this.previews.getTabForPreview(this);
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      
      <property name="loading">
        <getter>
        <![CDATA[
          return this.hasAttribute("loading") && (this.getAttribute("loading")=="true");
        ]]>
        </getter>
        <setter>
        <![CDATA[
          if (!val)
          {
            this.setAttribute("loading","false");
          }
          else
          {
            this.setAttribute("loading","true");
          }
          return val;
        ]]>
        </setter>
      </property>
      
      <!-- Configuration options -->
      <!-- Properties generated from the browser -->
      
      <property name="title">
        <getter>
          if (!this._browser)
          {
            return "";
          }
          var title = this._browser.contentTitle;
          if (title &amp;&amp; title.length&gt;0)
          {
            return title;
          }
          else
          {
            return "&tabsidebar.untitled;";
          }
        </getter>
      </property>

      <property name="uri">
        <getter>
          if (!this._browser)
          {
            return "";
          }
          var uri = this._browser.currentURI;
          if (uri)
          {
            return uri.spec;
          }
          else
          {
            return "";
          }
        </getter>
      </property>

      <!-- Methods -->
      
      <method name="update">
        <body>
          var uri = this.uri;
          var el = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","uri");
          if (el)
            el.value=uri;
          el = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","title");
          if (el)
            el.value=this.title;
          var reload = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","reload");
          reload.disabled=(uri=="about:blank" || uri=="");
        </body>
      </method>
      
      <method name="redraw">
        <body>
          if (!this._browser || this._loading || !this.previews.showPreview)
          {
            return;
          }
          var canvas = this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","canvas");
          var ctx = null;
          try
          {
            ctx = canvas.getContext("2d");
          }
          catch (e)
          {
            return;
          }
          var win = this._browser.contentWindow;
          ctx.clearRect(0, 0, this.previews.previewWidth, this.previews.previewHeight);
          ctx.save();
          ctx.scale(this.previews.previewWidth/win.innerWidth,this.previews.previewHeight/win.innerHeight);
          try
          {
            var top = 0;
            var left = 0;
            var height = win.innerHeight;
            var width = win.innerWidth;
            if (this.previews.drawScrolled)
            {
              top=win.scrollY;
              left=win.scrollX;
            }
            else
            {
              height=Math.max(height,win.scrollY+1);
            }
            ctx.drawWindow(win,left,top,width,height,"rgba(255,255,255,255)");
          }
          catch (e)
          {
            dump(e);
          }
          ctx.restore();
        </body>
      </method>
      
      <!--  Start of nsIWebProgressListener implementation -->

      <method name="onLocationChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="location"/>
        <body>
          this.update();
        </body>
      </method>
      
      <method name="onStateChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="stateFlags"/>
        <parameter name="status"/>
        <body>
        <![CDATA[
          if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_IS_DOCUMENT)
          {
          	if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_STOP)
          	{
              this._loadComplete();
            }
            else if (stateFlags & Components.interfaces.nsIWebProgressListener.STATE_START)
            {
              this._loadStarted();
            }
      		}
      	]]>
        </body>
      </method>
      
      <method name="onStatusChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="status"/>
        <parameter name="message"/>
        <body>
        </body>
      </method>
      
      <method name="onProgressChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="curSelfProgress"/>
        <parameter name="maxSelfProgress"/>
        <parameter name="curTotalProgress"/>
        <parameter name="maxTotalProgress"/>
        <body>
        </body>
      </method>
      
      <method name="onSecurityChange">
        <parameter name="webProgress"/>
        <parameter name="request"/>
        <parameter name="state"/>
        <body>
          this._setSecurity(state);
        </body>
      </method>
      
      <!--  Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._redrawTimer)
          {
            this.loading=false;
            this.update();
            this.redraw();
          }
          else if (timer==this._loadTimer)
          {
            this.update();
            this.redraw();
          }
        ]]>
        </body>
      </method>

    </implementation>

    <handlers>
      <handler event="click">
      <![CDATA[
        if (!this._browser)
        {
          return;
        }
        var tabbrowser = this.previews.tabbrowser;
        if (event.originalTarget.getAttribute("anonid")=="reload")
        {
          if (event.button==0 && !event.originalTarget.disabled)
            tabbrowser.reloadTab(this.tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="close")
        {
          if (event.button==0 && !event.originalTarget.disabled)
            tabbrowser.removeTab(this.tab);
        }
        else if (event.originalTarget.getAttribute("anonid")=="security")
        {
          if (tabbrowser.selectedTab!=this.tab)
          {
            tabbrowser.selectedTab=this.tab;
          }
          window.parent.displaySecurityInfo();
        }
        else
        {
          if (event.button==1)
          {
            tabbrowser.removeTab(this.tab);
          }
          else if (event.button==2)
          {
          }
          else
          {
            tabbrowser.selectedTab=this.tab;
          }
        }
      ]]>
      </handler>
    </handlers>
      
  </binding>

</bindings>
