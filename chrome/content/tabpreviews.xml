<?xml version="1.0"?>

 <!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Tab Sidebar Display.
   -
   - The Initial Developer of the Original Code is
   -     Dave Townsend <dave.townsend@blueprintit.co.uk>.
   - Portions created by the Initial Developer are Copyright (C) 2005
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK *****
   -
   - $HeadURL$
   - $LastChangedBy$
   - $Date$
   - $Revision$
   -->

<!DOCTYPE bindings [
<!ENTITY % tabSidebarDTD SYSTEM "chrome://tabsidebar/locale/tabsidebar.dtd" >
%tabSidebarDTD;
]>

<bindings id="TabSidebarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xhtml="http://www.w3.org/1999/xhtml">

  <binding id="tabpreviews" name="tabpreviews" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox">

    <resources>
      <stylesheet src="chrome://tabsidebar/content/tabpreviews.css"/>
    </resources>
    
    <content hide="">
      <xul:popupset>
      
        <xul:tooltip id="tabpreview_tooltip" orient="vertical">
          <xul:label value="Title"/>
          <xul:label style="display: none" value="URI"/>
        </xul:tooltip>
        
        <xul:popup id="tabpreview_context">
          <xul:menuitem id="newTab" label="&tabsidebar.newtab.label;"/>
          <xul:menuseparator/>
          <xul:menuitem id="reloadTab" label="&tabsidebar.reload.label;"/>
          <xul:menuitem id="reloadAllTabs" label="&tabsidebar.reloadall.label;"/>
          <xul:menuitem id="closeOtherTabs" label="&tabsidebar.closeother.label;"/>
          <xul:menuseparator hidden="true"/>
          <xul:menuitem id="bookmarkTab" hidden="true" label="&tabsidebar.bookmark.label;"/>
          <xul:menuitem id="bookmarkAllTabs" hidden="true" label="&tabsidebar.bookmarkall.label;"/>
          <xul:menuseparator/>
          <xul:menuitem id="refreshPreview" label="&tabsidebar.refresh.label;"/>
          <xul:menuitem id="refreshAllPreviews" label="&tabsidebar.refreshall.label;"/>
          <xul:menuseparator/>
          <xul:menuitem id="options" label="&tabsidebar.options.label;"/>
          <xul:menuseparator/>
          <xul:menuitem id="closeTab" label="&tabsidebar.close.label;"/>
        </xul:popup>
        
      </xul:popupset>
      
      <xul:scrollbox context="tabpreview_context" allowevents="true" anonid="scrollbox"
                     ondraggesture="nsDragAndDrop.startDrag(event, this.parentNode); event.stopPropagation();"
                     ondragover="nsDragAndDrop.dragOver(event, this.parentNode); event.stopPropagation();"
                     ondragdrop="nsDragAndDrop.drop(event, this.parentNode); event.stopPropagation();"
                     ondragexit="nsDragAndDrop.dragExit(event, this.parentNode); event.stopPropagation();">
        
        <xul:vbox class="tab-drop-indicator-bar">
          <xul:hbox class="tab-drop-indicator"/>
        </xul:vbox>          

        <xul:vbox align="stretch" flex="1">
          <children/>
        </xul:vbox>

      </xul:scrollbox>
    </content>
    
    <implementation implements="nsITimerCallback,nsIObserver">
    
      <constructor>
      <![CDATA[        
        this._initTree();
        this._migrateOldSettings();
        this._initSettings();
        
        var browsers = this.tabbrowser.browsers;
        for (var i=0; i<browsers.length; i++)
        {
          this.addPreview(browsers[i]);
        }
        
        this._initEvents();
      ]]>
      </constructor>
      
      <method name="_initTree">
        <body>
        	var drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
        	drop.className="dropindicator groove";
        	drop.setAttribute("orient","horizontal");
          this.previewContainer.appendChild(drop);
        </body>
      </method>

      <method name="_migrateOldSettings">
        <body>
          if (this.preferences.prefHasUserValue("content.buttons"))
          {
            var state = this.preferences.getBoolPref("content.buttons");
            this.preferences.setBoolPref("content.reload",state);
            this.preferences.setBoolPref("content.throbber",state);
            this.preferences.setBoolPref("content.close",state);
            this.preferences.clearUserPref("content.buttons");
          }
        </body>
      </method>

      <method name="_initSettings">
        <body>
          if (this.autoRefresh)
          {
            this._refreshTimer.initWithCallback(this, 
                                                this.refreshRate,
                                                Components.interfaces.nsITimer.TYPE_REPEATING_SLACK)
          }
          this.updateContent();        
        </body>
      </method>
      
      <method name="_initEvents">
        <body>
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefBranchInternal);
          prefs.addObserver("tabsidebar.", this, false);
        
        	var self=this;
        	this._eventListener = function(event) { self.eventFilter(event); };
        	
        	this.tabbrowser.tabContainer.addEventListener("DOMNodeInserted", this._eventListener, false);
        	var container = this.tabbrowser.mPanelContainer;
        	container.addEventListener("select", this._eventListener, false);
        	container.addEventListener("DOMNodeInserted", this._eventListener, false);
        	container.addEventListener("DOMNodeRemoved", this._eventListener, false);
        </body>
      </method>
      
      <destructor>
      	this.tabbrowser.tabContainer.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	var container = this.tabbrowser.mPanelContainer;
      	container.removeEventListener("select", this._eventListener, false);
      	container.removeEventListener("DOMNodeInserted", this._eventListener, false);
      	container.removeEventListener("DOMNodeRemoved", this._eventListener, false);

        var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                              .getService(Components.interfaces.nsIPrefBranchInternal);
        prefs.removeObserver("tabsidebar.", this);
      </destructor>
      
      <!-- Event handling gubbins -->

      <field name="_eventListener"/>

      <method name="eventFilter">
        <parameter name="event"/>
        <body>
          if (event.type=="DOMNodeInserted")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.addPreview(browser);
        		}
        		else if (event.relatedNode==previews.tabbrowser.tabContainer)
        		{
        		  var browser = event.target.linkedBrowser;
        		  if (browser)
        		  {
        		    this.movePreview(browser);
        		  }
        		}
          }
          else if (event.type=="DOMNodeRemoved")
          {
        		if (event.relatedNode==previews.tabbrowser.mPanelContainer)
        		{
          		var browser = event.target.childNodes[1];
          		this.removePreview(browser);
        		}
          }
          else if (event.type=="select")
          {
        		var newBrowser = this.tabbrowser.getBrowserAtIndex(this.tabbrowser.mTabContainer.selectedIndex);
        		this.selectPreview(newBrowser);
          }
        </body>
      </method>
      
      <!-- Internal fields and methods -->

      <field name="_selected"/>

      <field name="_refreshTimer">
        Components.classes["@mozilla.org/timer;1"].createInstance(Components.interfaces.nsITimer);
      </field>

      <method name="_resize">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i]._resize();
        	}
        	this.redraw();
        ]]>
        </body>
      </method>

      <!-- Helper properties -->

      <field name="preferences">
        Components.classes["@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefService)
                  .getBranch("tabsidebar.");
      </field>
      <field name="tabbrowser">window.parent.document.getElementById("content")</field>
      <field name="previewContainer">this</field>
      <field name="scrollBoxObject">
        this.ownerDocument.getAnonymousElementByAttribute(this,"anonid","scrollbox")
                          .boxObject.QueryInterface(Components.interfaces.nsIScrollBoxObject);
      </field>
      <field name="dragDropBar">this.ownerDocument.getAnonymousNodes(this)[1].firstChild</field>
      <field name="dragDropIndicator">this.dragDropBar.firstChild;</field>
      
      <property name="previews">
        <getter>
          return this.ownerDocument.getElementsByTagName("tabpreview");
        </getter>
      </property>
      
      <!-- Attribute based properties -->
      <!-- Configuration options -->

      <property name="showReload">
        <getter>
          return this.preferences.getBoolPref("content.reload");
        </getter>
      </property>
      
      <property name="showClose">
        <getter>
          return this.preferences.getBoolPref("content.close");
        </getter>
      </property>
      
      <property name="showFavicon">
        <getter>
          return this.preferences.getBoolPref("content.favicon");
        </getter>
      </property>
      
      <property name="showThrobber">
        <getter>
          return this.preferences.getBoolPref("content.throbber");
        </getter>
      </property>
      
      <property name="showSecurity">
        <getter>
          return this.preferences.getBoolPref("content.security");
        </getter>
      </property>
      
      <property name="showPreview">
        <getter>
        <![CDATA[
          return (this.previewWidth!=0 && this.previewHeight!=0 && this.preferences.getBoolPref("content.preview"));
        ]]>
        </getter>
      </property>
      
      <property name="showTitle">
        <getter>
          return this.preferences.getBoolPref("content.title");
        </getter>
      </property>
      
      <property name="showURI">
        <getter>
          return this.preferences.getBoolPref("content.uri");
        </getter>
      </property>
      
      <field name="_customSize">false</field>
      <property name="customSize">
        <getter>
          return this._customSize;
        </getter>
        <setter>
          if (this._customSize==val)
          {
            return val;
          }
          this._customSize=val;
          if (!val)
          {
            onResize();
          }
          redraw();
        </setter>
      </property>
      
      <field name="_width">-1</field>
      <property name="previewWidth">
        <getter>
          return this._width;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._width && this._customSize)
          {
            return val;
          }
          this._width=val;
          this.customSize=true;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <field name="_height">-1</field>
      <property name="previewHeight">
        <getter>
          return this._height;
        </getter>
        <setter>
        <![CDATA[
          if (val==this._height && this._customSize)
          {
            return val;
          }
          this._height=val;
          this.customSize=true;
          this._resize();
          return val;
        ]]>
        </setter>
      </property>
      
      <property name="autoRefresh">
        <getter>
          return this.preferences.getBoolPref("autorefresh");
        </getter>
      </property>
      
      <property name="refreshRate">
        <getter>
          return Math.max(5,this.preferences.getIntPref("refreshrate"))*1000;
        </getter>
      </property>
      
      <property name="loadRefresh">
        <getter>
          return this.preferences.getBoolPref("loadrefresh");
        </getter>
      </property>
      
      <property name="loadRefreshRate">
        <getter>
          return Math.max(100,this.preferences.getIntPref("loadrefreshrate"));
        </getter>
      </property>
      
      <property name="loadDelay">
        <getter>
          return this.preferences.getIntPref("loaddelay");
        </getter>
      </property>
      
      <property name="drawScrolled">
        <getter>
          return this.preferences.getBoolPref("drawscrolled");
        </getter>
      </property>
      
      <!-- Methods -->

      <method name="getPreviewForBrowser">
        <parameter name="browser"/>
        <body>
        <![CDATA[
          var preview = this.ownerDocument.getElementById(browser.parentNode.id);
        	if (preview)
        	{
        		return preview;
        	}
        	var id=browser.parentNode.id;
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		var preview = previews[i];
        		if (preview.browser==browser)
        		{
          		if (id)
          		{
          		  preview.id=id;
          		}
        		  return preview;
        		}
        	}
        	return null;
        ]]>
        </body>
      </method>
      
      <method name="getTabForPreview">
        <parameter name="preview"/>
        <body>
          var tabbrowser = this.tabbrowser;
          var panel = preview._browser.parentNode.id;
          return tabbrowser.ownerDocument.getAnonymousElementByAttribute(tabbrowser,"linkedpanel",panel);
        </body>
      </method>
      
      <method name="addPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.ownerDocument.createElement("tabpreview");
        	var drop = this.ownerDocument.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","separator");
        	drop.className="dropindicator groove";
        	drop.setAttribute("orient","horizontal");
        	var id=browser.parentNode.id;
        	if (id)
        	{
        		preview.id=id;
        	}
          var panel = browser.parentNode.id;
          var tab = this.tabbrowser.ownerDocument.getAnonymousElementByAttribute(this.tabbrowser,"linkedpanel",panel);
        	if (tab && tab.nextSibling)
        	{
        		var next = this.getPreviewForBrowser(tab.nextSibling.linkedBrowser);
        		if (next)
        		{
          		this.previewContainer.insertBefore(preview,next);
          		this.previewContainer.insertBefore(drop,next);
          	}
          	else
          	{
              this.previewContainer.appendChild(preview);
              this.previewContainer.appendChild(drop);
          	}
        	}
        	else
        	{
        		this.previewContainer.appendChild(preview);
        		this.previewContainer.appendChild(drop);
        	}
        	preview.init();
        	preview.browser=browser;
        	this.onResize();
        	
        	if (this.tabbrowser.selectedBrowser==browser)
        	{
        	  this.selectPreview(browser);
        	}
        ]]>
        </body>
      </method>
      
      <method name="removePreview">
        <parameter name="browser"/>
        <body>
        	var preview = this.getPreviewForBrowser(browser);
        	preview.browser=null;
        	var drop = preview.nextSibling;
        	preview.parentNode.removeChild(preview);
        	drop.parentNode.removeChild(drop);
        	this.onResize();
        </body>
      </method>
      
      <method name="movePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          if (preview)
          {
            this.removePreview(browser);
            this.addPreview(browser);
          }
        </body>
      </method>
      
      <method name="selectPreview">
        <parameter name="browser"/>
        <body>
        <![CDATA[
        	var preview = this.getPreviewForBrowser(browser);
        	if (this._selected)
        	{
            this._selected.setAttribute("selected","false");
        	}
        	if (preview)
        	{
          	preview.setAttribute("selected","true");
          }
        	this._selected=preview;
        	this.scrollBoxObject.ensureElementIsVisible(preview);
        ]]>
        </body>
      </method>
            
      <method name="updatePreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.update();
        </body>
      </method>
      
      <method name="redrawPreview">
        <parameter name="browser"/>
        <body>
          var preview = this.getPreviewForBrowser(browser);
          preview.redraw();
        </body>
      </method>

      <method name="updateContent">
        <body>
        <![CDATA[
          var canvasWasHidden=false;
          var hide = this.getAttribute("hide");
          if (hide.indexOf("preview")>=0)
            canvasWasHidden=true;
          
          hide = "";
          if (!this.showThrobber)
            hide+=" throbber";
          if (!this.showFavicon)
            hide+=" favicon";
          if (!this.showReload)
            hide+=" reload";
          if (!this.showClose)
            hide+=" close";
          if (!this.showPreview)
            hide+=" preview";
          if (!this.showTitle)
            hide+=" title";
          if (!this.showURI)
            hide+=" uri";
          if (!this.showSecurity)
            hide+=" security";
          
          if (hide.length>0)
            hide=hide.substring(1);
          
          this.setAttribute("hide",hide);
      
          var state = this.showPreview ? "false" : "true";
          var menu = this.ownerDocument.getAnonymousElementByAttribute(this,"id","refreshPreview");
          menu.setAttribute("disabled",state);
          menu = this.ownerDocument.getAnonymousElementByAttribute(this,"id","refreshAllPreviews");
          menu.setAttribute("disabled",state);

        	if (!this.onResize() && canvasWasHidden && this.showPreview)
        	{
        	  this.redraw();
        	}
        ]]>
        </body>
      </method>

      <method name="redraw">
        <body>
        <![CDATA[
        	var previews = this.previews;
        	for (var i=0; i<previews.length; i++)
        	{
        		previews[i].redraw();
        	}
        ]]>
        </body>
      </method>

      <method name="onResize">
        <body>
        <![CDATA[
          if (this.customSize)
          {
            return false;
          }
          var newWidth=0;
          var newHeight=0;
          var previews = this.previews;
          
          for (var i=0; i<previews.length; i++)
          {
            if (previews[i]._browser)
            {
              var preview = previews[i];
              var container = this.ownerDocument.getAnonymousElementByAttribute(preview,"anonid","canvas_container");
              var computed = window.getComputedStyle(container,null);
              newWidth = parseInt(computed.width);
              if (newWidth<0)
              {
                newWidth=0;
              }
              var bwidth = preview._browser.contentWindow.innerWidth;
              var bheight = preview._browser.contentWindow.innerHeight;
              newHeight = parseInt((bheight/bwidth)*newWidth);

              break;
            }
          }
          
          if (this._width!=newWidth || this._height!=newHeight)
          {
            this._width=newWidth;
            this._height=newHeight;
          	this._resize();
          	return true;
          }
          return false;
        ]]>
        </body>
      </method>
      
      <!-- Start of DnD implementation -->

      <field name="_lastDrop"/>
      
      <method name="_drawDropIndicator">
        <parameter name="drop"/>
        <body>
          if (drop!=this._lastDrop)
          {
            var pos = drop.boxObject.y+(drop.boxObject.height/2)-5;
            this.dragDropIndicator.style.marginTop = pos + "px";
            if (!this._lastDrop)
            {
              this.dragDropBar.setAttribute("dragging","true");
            }
            this._lastDrop=drop;
          }
        </body>
      </method>
      
      <method name="_hideDropIndicator">
        <body>
          if (this._lastDrop)
          {
            this._lastDrop=null;
            this.dragDropBar.setAttribute("dragging","false");
          }
        </body>
      </method>
      
      <method name="getDropElement">
        <parameter name="aEvent"/>
        <parameter name="external"/>
        <body>
        <![CDATA[
          var y = {};
          this.scrollBoxObject.getPosition({}, y);
          var ypos = aEvent.clientY+y.value;
          var diff = 0;
          var previews = this.previews;
          for (var i=0; i<previews.length; i++)
          {
            var bo = previews[i].boxObject;
            if (external)
            {
              if (bo.y>ypos)
              {
                return previews[i].previousSibling;
              }
              else if ((bo.y+bo.height)>=ypos)
              {
                return previews[i];
              }
            }
            else
            {
              if ((bo.y+(bo.height/2))>ypos)
              {
                return previews[i].previousSibling;
              }
            }
          }
          return previews[previews.length-1].nextSibling;
        ]]>
        </body>
      </method>
      
      <method name="onDragStart">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragAction"/>
        <body>
        <![CDATA[
          try
          {
            if (aEvent.target.localName=="tabpreview")
            {
              aXferData.data = new TransferData();
              
              var URI = aEvent.target._browser.currentURI;
              if (URI)
              {
                aXferData.data.addDataForFlavour("text/unicode", URI.spec);
                aXferData.data.addDataForFlavour("text/x-moz-url", URI.spec + "\n" + aEvent.target.contentTitle);
                aXferData.data.addDataForFlavour("text/html", '<a href="' + URI.spec + '">' + aEvent.target.contentTitle + '</a>');
              }
              else
              {
                aXferData.data.addDataForFlavour("text/unicode", "about:blank");
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDragOver">
        <parameter name="aEvent"/>
        <parameter name="aFlavour"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            var y = {};
            this.scrollBoxObject.getPosition({}, y);
            //dump("At "+y.value+" "+aEvent.clientY+"\n");
            if (y.value>0 && aEvent.clientY<10)
            {
              //dump("Scroll up!\n");
              this.scrollBoxObject.scrollByLine(-3);
            }
  
            if (!aDragSession.canDrop)
            {
              this._hideDropIndicator();
              return;
            }
              
            if (aDragSession.sourceNode &&
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var newpos = this.getDropElement(aEvent,false);
              this._drawDropIndicator(newpos);
            }
            else
            {
              if (aEvent.target.localName=="tabpreview")
              {
                this._drawDropIndicator(aEvent.target);
              }
              else
              {
                var newpos = this.getDropElement(aEvent,true);
                this._drawDropIndicator(newpos);
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDrop">
        <parameter name="aEvent"/>
        <parameter name="aXferData"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (aDragSession.sourceNode && 
               (aDragSession.sourceNode.parentNode == this || aDragSession.sourceNode.parentNode == this.tabbrowser.mTabContainer))
            {
              var preview = null
              if (aDragSession.sourceNode.parentNode == this)
              {
                preview = aDragSession.sourceNode;              
              }
              else
              {
                preview = this.getPreviewForBrowser(aDragSession.sourceNode.linkedBrowser);
              }
              
              var newIndex = this.previews.length;
              var target = this.getDropElement(aEvent,false);
              if (target.nextSibling)
              {
                target = target.nextSibling;
                newIndex = target.tab._tPos;
              }
              
              var previews = this.previews;
              var oldIndex = preview.tab._tPos;
              
              if (newIndex>oldIndex)
                newIndex--;
                
              if (newIndex==oldIndex)
                return;
  
              this.tabbrowser.moveTabTo(preview.tab, newIndex);
            }
            else
            {
              var url = transferUtils.retrieveURLFromData(aXferData.data, aXferData.flavour.contentType);
  
              // valid urls don't contain spaces ' '; if we have a space it isn't a valid url.
              // Also disallow dropping javascript: or data: urls--bail out
              if (!url || !url.length || url.indexOf(" ", 0) != -1 ||
                  /^\s*(javascript|data):/.test(url))
                return;
  
              this.tabbrowser.dragDropSecurityCheck(aEvent, aDragSession, url);
  
              var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                    .getService(Components.interfaces.nsIPrefService);
              var bgLoad = true;
              try
              {
                bgLoad = prefs.getBoolPref("browser.tabs.loadInBackground");
              }
              catch (e) { }
  
              if (aEvent.shiftKey)
                bgLoad = !bgLoad;
  
              if (aEvent.target.localName != "tabpreview")
              {
                // We're adding a new tab.
                var move = false;
                var newIndex = this.previews.length;
                var target = this.getDropElement(aEvent,false);
                if (target.nextSibling)
                {
                  target = target.nextSibling;
                  newIndex = target.tab._tPos;
                  move = true;
                }
  
                var newtab = this.tabbrowser.loadOneTab(url, null, null, null, bgLoad);
                
                if (move)
                  this.tabbrowser.moveTabTo(newtab, newIndex);
              }
              else
              {
                // Load in an existing tab.
                var preview = aEvent.target;
                preview.browser.loadURI(url);
  
                if (this.tabbrowser.selectedTab != preview.tab && !bgLoad)
                  this.tabbrowser.selectedTab = preview.tab;
              }
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="onDragExit">
        <parameter name="aEvent"/>
        <parameter name="aDragSession"/>
        <body>
        <![CDATA[
          try
          {
            if (!aEvent.relatedTarget && this._lastDrop)
            {
              this._hideDropIndicator();
            }
          }
          catch (e)
          {
            dump(e);
          }
        ]]>
        </body>
      </method>

      <method name="getSupportedFlavours">
        <body>
        <![CDATA[
          var flavourSet = new FlavourSet();
          flavourSet.appendFlavour("text/x-moz-url");
          flavourSet.appendFlavour("text/unicode");
          flavourSet.appendFlavour("application/x-moz-file", "nsIFile");
          return flavourSet;
        ]]>
        </body>
      </method>

      <!-- Start of nsITimerCallback implementation -->

      <method name="notify">
        <parameter name="timer"/>
        <body>
        <![CDATA[
          if (timer==this._refreshTimer)
          {
            this.redraw();
          }
        ]]>
        </body>
      </method>
      
      <!-- Start of nsIObserver implementation -->

      <method name="observe">
        <parameter name="subject"/>
        <parameter name="topic"/>
        <parameter name="data"/>
        <body>
        <![CDATA[
          data=data.substring(11);
          switch (data)
          {
            case "content.favicon":
            case "content.preview":
            case "content.close":
            case "content.security":
            case "content.reload":
            case "content.throbber":
            case "content.title":
            case "content.uri":
              this.updateContent();
              break;
            case "refreshrate":
            case "autorefresh":
              this._refreshTimer.cancel();
              if (this.autoRefresh)
              {
                this._refreshTimer.initWithCallback(this, 
                                                    this.refreshRate,
                                                    Components.interfaces.nsITimer.TYPE_REPEATING_SLACK)
              }
              break;
            case "drawscrolled":
              this.redraw();
              break;
            case "previewWidth":
              if (this.preferences.prefHasUserValue(data))
              {
                this.previewWidth=this.preferences.getIntPref(data);
              }
              else
              {
                this.customSize=false;
              }
              break;
            case "previewHeight":
              if (this.preferences.prefHasUserValue(data))
              {
                this.previewHeight=this.preferences.getIntPref(data);
              }
              else
              {
                this.customSize=false;
              }
              break;
          }
        ]]>
        </body>
      </method>
    </implementation>
    
    <handlers>
      
      <handler event="command">
      <![CDATA[
        if (event.originalTarget.id=="newTab")
        {
          var newTab = this.tabbrowser.addTab("about:blank");
          this.tabbrowser.selectedTab=newTab;
        }
        else if (event.originalTarget.id=="reloadTab")
        {
          this.tabbrowser.reloadTab(this.ownerDocument.popupNode.tab);
        }
        else if (event.originalTarget.id=="reloadAllTabs")
        {
          this.tabbrowser.reloadAllTabs();
        }
        else if (event.originalTarget.id=="closeOtherTabs")
        {
          this.tabbrowser.removeAllTabsBut(this.ownerDocument.popupNode.tab);
        }
        else if (event.originalTarget.id=="bookmarkTab")
        {
        }
        else if (event.originalTarget.id=="bookmarkAllTabs")
        {
        }
        else if (event.originalTarget.id=="refreshPreview")
        {
          this.ownerDocument.popupNode.redraw();
        }
        else if (event.originalTarget.id=="refreshAllPreviews")
        {
          this.redraw();
        }
        else if (event.originalTarget.id=="closeTab")
        {
          this.tabbrowser.removeTab(this.ownerDocument.popupNode.tab);
        }
        else if (event.originalTarget.id=="options")
        {
          var prefs = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefService);
          var instantApply = prefs.getBoolPref("browser.preferences.instantApply", false);
          var features = "chrome,titlebar,toolbar,centerscreen" + (instantApply ? ",dialog=no" : ",modal");
        
          var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                             .getService(Components.interfaces.nsIWindowMediator);
          var win = wm.getMostRecentWindow("TabSidebar:Options");
          if (win)
          {
            win.focus();
          }
          else
          {
            window.openDialog("chrome://tabsidebar/content/preferences.xul",
                              "Preferences", features);
        	}
        }
      ]]>
      </handler>
      
      <handler event="dblclick">
      <![CDATA[
        if (event.button==0 && event.originalTarget.parentNode.parentNode==this)
        {
          var newTab = this.tabbrowser.addTab("about:blank");
          this.tabbrowser.selectedTab=newTab;
        }
      ]]>
      </handler>
      
      <handler event="popupshowing">
      <![CDATA[
        if (event.originalTarget.id=="tabpreview_tooltip")
        {
          var preview = this.ownerDocument.tooltipNode;
          while (preview.localName!="tabpreview")
          {
            preview=preview.parentNode;
          }
          event.originalTarget.childNodes[0].value=preview.title;
          event.originalTarget.childNodes[1].value=preview.uri;
        }
        else if (event.originalTarget.id=="tabpreview_context")
        {
          var preview = this.ownerDocument.popupNode;
          while (preview && preview.localName!="tabpreview")
          {
            preview=preview.parentNode;
          }
          
          var state = !preview ? "true" : "false";
          
          this.ownerDocument.getAnonymousElementByAttribute(this,"id","reloadTab").setAttribute("disabled",state);
          this.ownerDocument.getAnonymousElementByAttribute(this,"id","closeOtherTabs").setAttribute("disabled",state);
          this.ownerDocument.getAnonymousElementByAttribute(this,"id","bookmarkTab").setAttribute("disabled",state);
          this.ownerDocument.getAnonymousElementByAttribute(this,"id","refreshPreview").setAttribute("disabled",state);
          this.ownerDocument.getAnonymousElementByAttribute(this,"id","closeTab").setAttribute("disabled",state);

          state = (this.previews.length<=1) ? "true" : "false";

          this.ownerDocument.getAnonymousElementByAttribute(this,"id","bookmarkAllTabs").setAttribute("disabled",state);
        }
      ]]>
      </handler>

    </handlers>

  </binding>
  
</bindings>
